{"meta":{"title":"COFFEECODE","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-05-01T05:55:46.977Z","updated":"2020-05-01T05:55:46.977Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-05-01T05:55:46.978Z","updated":"2020-05-01T05:55:46.978Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2020-05-01T09:40:01.965Z","updated":"2020-05-01T09:40:01.965Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-05-01T05:55:46.978Z","updated":"2020-05-01T05:55:46.978Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-05-01T05:55:46.979Z","updated":"2020-05-01T05:55:46.979Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-05-01T05:55:46.979Z","updated":"2020-05-01T05:55:46.979Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-05-01T05:55:46.979Z","updated":"2020-05-01T05:55:46.979Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"gallery","date":"2020-05-01T05:40:35.000Z","updated":"2020-05-01T05:40:35.574Z","comments":true,"path":"gallery/index.html","permalink":"http://yoursite.com/gallery/index.html","excerpt":"","text":""}],"posts":[{"title":"Zepplin Mysql数据可视化","slug":"Zepplin-显示Mysql数据","date":"2020-05-31T12:25:45.000Z","updated":"2020-05-31T14:18:13.667Z","comments":true,"path":"2020/05/31/Zepplin-显示Mysql数据/","link":"","permalink":"http://yoursite.com/2020/05/31/Zepplin-%E6%98%BE%E7%A4%BAMysql%E6%95%B0%E6%8D%AE/","excerpt":"","text":"Zepplin Mysql数据可视化 配置拦截器（JDBC） 创建一个自定义拦截器 配置JDBC的连接 Properties Name Value default.driver com.mysql.jdbc.Driver default.url jdbc:mysql://localhost:3306/ default.user mysql_user default.password mysql_password 必填！！！ 配置依赖（Mysql驱动） 到你本地的LInux环境中找到你的MySQL驱动包： /opt/software/mysql-libs/mysql-connector-java-5.1.27/mysql-connector-java-5.1.27-bin.jar 点击保存 不见了，可以搜索MySQL 创建Notebook 创建notebook 点击 Create 创建成功 进入数据显示页面 编写第一条sql语句时要在前面添加 %mysql 其中“mysql”是你的拦截器名称 显示所有数据库 12%mysqlshow databases; 查询数据 12%mysqlselect * from staff; 其语句和Mysql语句完全一样。","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"zepplin","slug":"框架/BigData/zepplin","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/zepplin/"}],"tags":[{"name":"zepplin","slug":"zepplin","permalink":"http://yoursite.com/tags/zepplin/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"zepplin","slug":"框架/BigData/zepplin","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/zepplin/"}]},{"title":"Zepplin 配置安装","slug":"zepplin-配置安装","date":"2020-05-31T11:50:11.000Z","updated":"2020-05-31T12:24:46.015Z","comments":true,"path":"2020/05/31/zepplin-配置安装/","link":"","permalink":"http://yoursite.com/2020/05/31/zepplin-%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85/","excerpt":"","text":"Zepplin 配置安装 Zeppelin简介 官网：http://zeppelin.apache.org/ Apache Zeppelin是一款基于Web的Notebook(类似于jupyter notebook)，支持交互式地数据分析。 Zeppelin可实现你所需要的： 数据采集 数据发现 数据分析 数据可视化和协作 支持多种语言，默认是Scala(背后是Spark shell)，SparkSQL, Markdown ，SQL，Shell，Markdown和Python等 安装 解压 tar -zxvf zeppelin-0.8.0-bin-all.tgz -C /opt/module/ 启动Zeppelin 1234[root@hadoop141 zeppelin-0.8.0]# bin/zeppelin-daemon.sh startLog dir doesn't exist, create /opt/module/zeppelin-0.8.0/logsPid dir doesn't exist, create /opt/module/zeppelin-0.8.0/runZeppelin start [ OK ] 查看进程 123456789[root@hadoop141 zeppelin-0.8.0]# netstat -nltpActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 :::8080 :::* LISTEN 4328/java [root@hadoop141 bin]# jps2818 DataNode2707 NameNode4328 ZeppelinServer4425 Jps 访问：http://hadoop141:8080/ 配置成功","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"zepplin","slug":"框架/BigData/zepplin","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/zepplin/"}],"tags":[{"name":"zepplin","slug":"zepplin","permalink":"http://yoursite.com/tags/zepplin/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"zepplin","slug":"框架/BigData/zepplin","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/zepplin/"}]},{"title":"大数据学习路线","slug":"大数据学习路线","date":"2020-05-28T07:38:58.000Z","updated":"2020-05-28T14:21:28.341Z","comments":true,"path":"2020/05/28/大数据学习路线/","link":"","permalink":"http://yoursite.com/2020/05/28/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/","excerpt":"","text":"大数据学习路线 引言 本文的目的是希望给所有大数据初学者规划一条比较清晰的学习路线，帮助他们开启大数据学习之旅。鉴于大数据领域内的技术绚丽繁复，每位大数据初学者都应该根据自己的实际情况制定专属的学习路径。 大数据，即Big Data，关于它的定义很多，最权威的莫属IBM的定义，读者可以自行查阅，笔者在这里不再赘述。既然本文关注的是如何学习大数据，那么我们首先就要定义大数据领域内的不同角色，这样各位读者才能根据自身实际情况找准自己的定位，从而开启学习过程。 角色 当下大数据行业有如下两类角色： 大数据工程师 大数据分析 这两类角色相互依存但又独立运作，何意？没有大数据工程，大数据分析便无从谈起；但若没有大数据分析，大数据工程也没有存在的理由。这就类似于结婚和谈恋爱——谈恋爱的目的是为了结婚，且不以结婚为目的的谈恋爱都是耍流氓。 具体来说，大数据工程需要解决数据的定义、收集、计算与保存的工作，因此大数据工程师们在设计和部署这样的系统时首要考虑的是数据高可用的问题，即大数据工程系统需要实时地为下游业务系统或分析系统提供数据服务；而大数据分析角色定位于如何利用数据——即从大数据工程系统中接收到数据之后，如何为企业或组织提供有产出的数据分析，并且确实能够帮助公司进行业务改善或提升服务水平，所以对于大数据分析师来说，他们首要解决的问题是发现并利用数据的价值，具体可能包括：趋势分析、模型建立以及预测分析等。 简单总结一下，大数据工程角色需要考虑数据的收集、计算(或是处理)和保存；大数据分析角色则是执行数据的高级计算。 我们属于哪种角色 既然我们了解了大数据领域内的角色分类，下面自然就需要“对号入座”确定自己的定位，这样才能有的放矢地开始学习大数据。在考虑这个问题时，我们需要参考如下两方面的因素。 专业知识背景 行业经验 这里的专业知识背景不是指学历、院校这种背景，而是你对某些IT技术的了解程度。即使你不是计算机专业出身，只要你对C语言有一腔热血，哪怕是C之父Dennis Ritchie也不敢小瞧你。因此，这里的专业知识其实就只有如下两个： 计算机专业知识，比如操作系统、编程语言、计算机运行原理等。 数学知识，这里指代的是高等数学，比如微积分、概率统计、线性代数和离散数学等，并不是x×x+y×y= 1画出来是什么图形这样的数学。 而行业经验指的是你在相关领域内的工作经验，具体可以分为如下3档： 菜鸟； 有一定经验的工程师； 资深专家——现在在大数据领域内有一个更酷的名字，即数据科学家，比如前百度首席数据科学家吴恩达博士。 好了，现在我们就可以根据上面的分类来定义自己的角色。比如拿笔者来说，对自己的定位是：“我是一名计算机专业毕业的工程师，有一定的数学基础(特别是在微积分和线性代数方面)，但数理统计和概率论部分不是我的强项。”另外最好别打肿脸充胖子，如果之前没什么经验，承认自己是菜鸟也没事，关键是找准自己的定位。 确定自己的定位后，我们需要对应到特定的大数据角色，以下是一些基本法则： 如果您具有良好的编程基础且深入了解计算机的交互方式以及互联网底层技术原理，但数学和统计学掌握得不深，那么大数据工程可能是您今后学习的方向。 如果您有一定的编程基础(掌握一些高级语言，如Python等)，同时又有很强的数学功底，那么大数据分析可能是您努力的方向。 学习路线 不管您属于以上哪种角色，有一些大数据理论知识是您必须要掌握的，它们包括但不限于以下这些。 数据分片与路由：挑一个典型的分区算法去学习，比如一致性哈希算法 (https://en.wikipedia.org/wiki/Consistent_hashing)。 备份机制与一致性。 ​ √ 学习国内被奉为“圣经”但在国外也就一般的CAP理论 (https://en.wikipedia.org/wiki/CAP_theorem)。 ​ √ 幂等性（Idempotent），很多分布式系统状态管理的基石 (https://mortoray.com/2014/09/05/what-is-an-idempotent-function/)。 ​ √ 各种一致性模型：强一致性、弱一致性、最终一致性。 ​ √ 备份机制：主从的叫法已经不怎么流行了，当前更酷的叫法是Leader-Follower模式。 ​ √ 共识协议：国内通常翻译成一致性协议（consensus protocol）。学习常见的Paxos和Raft协议。 算法和数据结构。 ​ √ LSM：学习其与B+树的区别以及优势是什么。 ​ √ 压缩算法：了解一个主流的压缩算法，比如Snappy、LZ4。另外Facebook最近开源了新一代的压缩算法Zstandard，据说可以完爆一切主流压缩算法。 ​ √ Bloom Filter过滤器：大数据下O(1)的过滤器。 无论是学习大数据工程还是大数据分析，这些理论知识都是必要的，因为它们是设计很多分布式系统必备的技能。下面我们就针对不同的角色设计不同的学习路线。 大数据工程师 对于大数据工程师而言，您至少要掌握以下技能： 一门JVM系语言：当前大数据生态JVM系语言类的比重极大，在某种程度上说是垄断也不为过。这里笔者推荐大家学习Java或Scala，至于Clojure这样的语言上手不易，其实并不推荐大家使用。另外，如今是“母以子贵”的年代，某个大数据框架会带火它的编程语言，比如Docker之于Go、Kafka之于Scala。因此笔者这里建议您至少要精通一门JVM系的语言。值得一提的，一定要弄懂这门语言的多线程模型和内存模型，很多大数据框架的处理模式其实在语言层面与多线程处理模式是类似的，只是大数据框架把它们引申到了多机分布式这个层面。 笔者建议：学习Java或Scala。 计算处理框架：严格来说，分为离线批处理和流式处理。流式处理是未来的趋势，建议大家一定要学习；而离线批处理其实已经快过时了，它的分批处理思想无法处理无穷数据集，因此适用范围日益缩小。事实上，Google已经在公司内部正式废弃了以MapReduce为代表的离线处理。因此如果要学习大数据工程，掌握一门实时流式处理框架是必需。当下主流的框架包括Apache Samza、Apache Storm、Apache Spark Streaming以及最近一年风头正劲的Apache Flink。当然Apache Kafka也推出了它自己的流式处理框架Kafka Streams。 笔者建议：学习Flink、Spark Streaming或Kafka Streams中的一种。另外，请熟读Google大神的这篇文章《The world beyond batch: Streaming 101》，地址是https://www.oreilly.com/ideas/the-world-beyond-batch-streaming-101。 分布式存储框架：虽说MapReduce有些过时了，但Hadoop的另一个基石HDFS依然坚挺，并且是开源社区最受欢迎的分布式存储框架，绝对值得您花时间去学习。如果想深入研究的话，Google的GFS论文也是一定要读的 (https://static.googleusercontent.com/media/research.google.com/en//archive/gfs-sosp2003.pdf)。当然开源世界中还有很多的分布式存储框架，国内阿里巴巴的OceanBase是其中很优秀的一款。 笔者建议：学习HDFS。 资源调度框架：Docker可是整整火了最近一两年。各个公司都在发力基于Docker的容器解决方案，最有名的开源容器调度框架就是Kubernetes了，但同样著名的还有Hadoop的YARN和Apache Mesos。后两者不仅可以调度容器集群，还可以调度非容器集群，非常值得我们学习。 笔者建议：学习YARN。 分布式协调框架：有一些通用的功能在所有主流大数据分布式框架中都需要实现，比如服务发现、领导者选举、分布式锁、KV存储等。这些功能促进了分布式协调框架的发展。最古老也是最有名的当属Apache Zookeeper了，新一些的包括Consul、Etcd等。学习大数据工程，分布式协调框架是不能不了解的，从某种程度上说还应该深入了解。 笔者建议：学习ZooKeeper——太多大数据框架都需要它，比如Kafka、Storm、HBase等。 KV数据库：典型的就是Memcache和Redis了，特别是Redis简直发展神速。Redis简单的API设计和高性能的TPS日益得到广大用户的青睐。即使不学习大数据，学学Redis都是大有裨益的。 笔者建议：学习Redis，如果C语言功底好，最好熟读源码，其源码也不是很多。 列式存储数据库：笔者曾经花了很长的时间学习Oracle，但不得不承认当下关系型数据库已经慢慢地淡出了人们的视野，有太多的方案可以替代RDBMS了。人们针对行式存储不适用于大数据Ad-Hoc查询这种弊端开发出列式存储，典型的列式存储数据库就是开源社区的HBase。实际上列式存储的概念也是出自Google的一篇论文《Google BigTable》，大家有兴趣的话最好读一下 (https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf)。 笔者建议：学习HBase，这是目前应用最广泛的开源列式存储。 消息队列：大数据工程处理中消息队列作为“削峰填谷”的主力系统是必不可少的，当前该领域内的解决方案有很多，包括ActiveMQ、Kafka等。国内阿里也开源了RocketMQ。这其中的翘楚当属Apache Kafka了。Kafka的很多设计思想都特别契合分布流式数据处理的设计理念。这也难怪，Kafka的原作者Jay Kreps可是当今实时流式处理方面的顶级大神。 笔者建议：学习Kafka，不仅好找工作(几乎所有大数据招聘简历都要求会Kafka:-）)，还能触类旁通地进一步理解基于备份日志方式的数据处理范型。 大数据分析师或数据科学家 要想成为一名数据科学家，您至少要掌握以下技能： 数学功底：微积分是必须要掌握的。不一定要掌握多元微积分，但一元微积分是必须要熟练掌握并使用的。另外线性代数一定要精通，特别是矩阵的运算、向量空间、秩等概念。当前机器学习框架中很多计算都需要用到矩阵的乘法、转置或是求逆。虽然很多框架都直接提供了这样的工具，但我们至少要了解内部的原型原理，比如如何高效判断一个矩阵是否存在逆矩阵并如何计算等。 笔者建议：重温同济版《高等数学》，有条件的可以去Coursea学习宾夕法尼亚大学的微积分课程。推荐学习Strang的线性代数《Introduction to Linear Algebra》——这是最经典的教材，没有之一！ 数理统计：概率论和各种统计学方法要做到基本掌握，比如贝叶斯概率如何计算？概率分布是怎么回事？虽不要求精通，但对相关背景和术语一定要了解。 笔者建议：找一本《概率论》重新学习下。 交互式数据分析框架：这里并不是指SQL或数据库查询，而是像Apache Hive或Apache Kylin这样的分析交互框架。开源社区中有很多类似的框架，可以使用传统的数据分析方式对大数据进行数据分析或数据挖掘。笔者有过使用经验的是Hive和Kylin。不过Hive特别是Hive1是基于MapReduce的，性能并非特别出色，而Kylin采用数据立方体的概念结合星形模型，可以做到极低延时的分析速度，况且Kylin是第一个研发团队主力是中国人的Apache孵化项目，因此日益受到广泛的关注。 笔者建议：首先学习Hive，有时间的话了解一下Kylin以及背后的数据挖掘思想。 机器学习框架：机器学习当前真是火爆宇宙了，人人都提机器学习和AI，但笔者一直认为机器学习恰似几年前的云计算，目前虽然火爆，但没有实际的落地项目，可能还需要几年的时间才能逐渐成熟。不过现在就开始储备机器学习的知识总是没有坏处的。说到机器学习的框架，大家耳熟能详的有很多种,信手拈来的就有TensorFlow、Caffe8、Keras9、CNTK10、Torch711等，其中又以TensorFlow领衔。 笔者建议：可以选取一个机器学习框架进行学习，但这些框架大多封装了各种机器学习算法提供给用户使用，因此还是从机器学习算法的原理来学习比较好，比如：Udacity的课程是非常入门级的机器学习课程 (https:// classroom.udacity.com/courses/ud120)；目前机器学习领域最牛的入门课程，即吴恩达博士的Machine Learning；学习Python的scikit-learn库 (http://scikit-learn.org/stable/)；找一本书籍来看，国内有周志华的《机器学习》，还可以期待吴恩达的新书《Machine Learning Yearning》；最后如果觉得掌握得差不多了，可以尝试挑战Kaggle (https://www.kaggle.com/)。 总结 以上就是我对大数据学习路线的一些思考和建议，希望对读者朋友们有所帮助。 原文：https://mp.weixin.qq.com/s/lCBgJjKC117tnTCMsDThiA","categories":[{"name":"BigData","slug":"BigData","permalink":"http://yoursite.com/categories/BigData/"}],"tags":[{"name":"BigData","slug":"BigData","permalink":"http://yoursite.com/tags/BigData/"}],"keywords":[{"name":"BigData","slug":"BigData","permalink":"http://yoursite.com/categories/BigData/"}]},{"title":"Sqoop 简单使用","slug":"Sqoop-简单使用","date":"2020-05-21T08:54:34.000Z","updated":"2020-05-21T09:41:33.006Z","comments":true,"path":"2020/05/21/Sqoop-简单使用/","link":"","permalink":"http://yoursite.com/2020/05/21/Sqoop-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Sqoop 简单使用 导入数据 ​ 在 Sqoop 中，“导入”概念指：从非大数据集群（RDBMS）向大数据集群（HDFS、HIVE、HBASE）中传输数据，叫做：导入，即使用 import 关键字。 RDBMS 到 HDFS 确定 MYsql 服务正常开启； 在Mysql中新建一张测试表并插入测试数据: 123456789101112131415161718192021222324252627[root@hadoop141 ~]# mysql -uroot -p123456mysql&gt; create database company; mysql&gt; show databases;+--------------------+| Database |+--------------------+| company | +--------------------+mysql&gt; create table company.staff( -&gt; id int(4) primary key not null auto_increment, -&gt; name varchar(255), -&gt; sex varchar(255) -&gt; );mysql&gt; use company;mysql&gt; show tables;+-------------------+| Tables_in_company |+-------------------+| staff |+-------------------+mysql&gt; insert into company.staff(name, sex) values(&#39;Thomas&#39;, &#39;Male&#39;);mysql&gt; insert into company.staff(name, sex) values(&#39;Catalina&#39;, &#39;FeMale&#39;); 导入数据: 全部导入: 123456789$ bin/sqoop import \\--connect jdbc:mysql://hadoop141:3306/company \\--username root \\--password 123456 \\--table staff \\--target-dir /user/sqoop/company \\--delete-target-dir \\--num-mappers 1 \\--fields-terminated-by \"\\t\" 查询导入: 123456789$ bin/sqoop import \\--connect jdbc:mysql://hadoop141:3306/company \\--username root \\--password 000000 \\--target-dir /user/company \\--delete-target-dir \\--num-mappers 1 \\--fields-terminated-by \"\\t\" \\--query 'select name,sex from staff where id &lt;=1 and $CONDITIONS;' 提示：must contain ‘$CONDITIONS’ in WHERE clause. 如果query后使用的是双引号，则$CONDITIONS前必须加转移符，防止shell识别为自己的变量。 导入指定列: 12345678910$ bin/sqoop import \\--connect jdbc:mysql://hadoop141:3306/company \\--username root \\--password 000000 \\--target-dir /user/company \\--delete-target-dir \\--num-mappers 1 \\--fields-terminated-by \"\\t\" \\--columns id,sex \\--table staff 使用 Sqoop 关键字筛选查询导入数据: 12345678910$ bin/sqoop import \\--connect jdbc:mysql://hadoop141:3306/company \\--username root \\--password 000000 \\--target-dir /user/company \\--delete-target-dir \\--num-mappers 1 \\--fields-terminated-by \"\\t\" \\--table staff \\--where \"id=1\"","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"Sqoop","slug":"框架/BigData/Sqoop","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/Sqoop/"}],"tags":[{"name":"Sqoop","slug":"Sqoop","permalink":"http://yoursite.com/tags/Sqoop/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"Sqoop","slug":"框架/BigData/Sqoop","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/Sqoop/"}]},{"title":"Sqoop 安装","slug":"Sqoop-安装","date":"2020-05-21T02:09:17.000Z","updated":"2020-05-21T08:45:39.240Z","comments":true,"path":"2020/05/21/Sqoop-安装/","link":"","permalink":"http://yoursite.com/2020/05/21/%C2%96Sqoop-%E5%AE%89%E8%A3%85/","excerpt":"","text":"Sqoop 安装 Sqoop 简介 ​ Sqoop是一款开源的工具，主要用于在Hadoop(Hive)与传统的数据库(mysql、postgresql…)间进行数据的传递，可以将一个关系型数据库（例如 ： MySQL ,Oracle ,Postgres等）中的数据导进到Hadoop的HDFS中，也可以将HDFS的数据导进到关系型数据库中。 ​ Sqoop项目开始于2009年，最早是作为Hadoop的一个第三方模块存在，后来为了让使用者能够快速部署，也为了让开发人员能够更快速的迭代开发，Sqoop独立成为一个Apache项目。 ​ Sqoop2的最新版本是1.99.7。请注意，2与1不兼容，且特征不完整，它并不打算用于生产部署。 Sqoop 官网 官网： http://sqoop.apache.org 1.4.7官方文档： http://sqoop.apache.org/docs/1.4.7/SqoopUserGuide.html Sqoop 原理 ​ 将导入或导出命令翻译成mapreduce程序来实现。 ​ 在翻译出的mapreduce中主要是对inputformat和outputformat进行定制。 Sqoop 安装 1. 下载并解压 下载地址：http://mirrors.hust.edu.cn/apache/sqoop/1.4.7/ 上传安装包sqoop-1.4.7.bin__hadoop-2.6.0.tar.gz到虚拟机中 解压sqoop安装包到指定目录，如： $ tar -zxf sqoop-1.4.7.bin__hadoop-2.6.0.tar.gz -C /opt/module/ 2. 修改配置文件 1) 重命名配置文件 $ cd /opt/module/sqoop-1.4.7.bin__hadoop-2.6.0/conf $ mv sqoop-env-template.sh sqoop-env.sh 2) 修改配置文件 vim sqoop-env.sh 1234567891011121314151617181920#Set path to where bin/hadoop is available#export HADOOP_COMMON_HOME=export HADOOP_COMMON_HOME=/opt/module/hadoop-2.7.2#Set path to where hadoop-*-core.jar is available#export HADOOP_MAPRED_HOME=export HADOOP_MAPRED_HOME=/opt/module/hadoop-2.7.2#set the path to where bin/hbase is available#export HBASE_HOME=export HBASE_HOME=/opt/module/hbase-1.3.1#Set the path to where bin/hive is available#export HIVE_HOME=export HIVE_HOME=/opt/module/hive-2.3.6#Set the path for where zookeper config dir is#export ZOOCFGDIR=export ZOOKEEPER_HOME=/opt/module/zookeeper-3.4.10export ZOOCFGDIR=/opt/module/zookeeper-3.4.10 3. 拷贝JDBC驱动 ​ 拷贝jdbc驱动到sqoop的lib目录下，如: cp mysql-connector-java-5.1.27-bin.jar /opt/module/sqoop-1.4.7.bin__hadoop-2.6.0/lib/ 4. 验证Sqoop ​ 输入命令： bin/sqoop help ​ 出现一些Warning警告，并伴随着帮助命令的输出： 12345678910111213141516171819202122232425[root@hadoop141 sqoop-1.4.7.bin__hadoop-2.6.0]# bin/sqoop helpWarning: /opt/module/sqoop-1.4.7.bin__hadoop-2.6.0/bin/../../hcatalog does not exist! HCatalog jobs will fail.Please set $HCAT_HOME to the root of your HCatalog installation.Warning: /opt/module/sqoop-1.4.7.bin__hadoop-2.6.0/bin/../../accumulo does not exist! Accumulo imports will fail.Please set $ACCUMULO_HOME to the root of your Accumulo installation.20/05/21 07:36:41 INFO sqoop.Sqoop: Running Sqoop version: 1.4.7usage: sqoop COMMAND [ARGS]Available commands: codegen Generate code to interact with database records create-hive-table Import a table definition into Hive eval Evaluate a SQL statement and display the results export Export an HDFS directory to a database table help List available commands import Import a table from a database to HDFS import-all-tables Import tables from a database to HDFS import-mainframe Import datasets from a mainframe server to HDFS job Work with saved jobs list-databases List available databases on a server list-tables List available tables in a database merge Merge results of incremental imports metastore Run a standalone Sqoop metastore version Display version informationSee 'sqoop help COMMAND' for information on a specific command. 5. 测试Sqoop是否能够成功连接数据库 ​ 执行命令： bin/sqoop list-databases --connect jdbc:mysql://hadoop141:3306/ --username 数据库用户名--password 数据库密码 ​ 出现如下输出： 123456789101112Warning: /opt/module/sqoop-1.4.7.bin__hadoop-2.6.0/bin/../../hcatalog does not exist! HCatalog jobs will fail.Please set $HCAT_HOME to the root of your HCatalog installation.Warning: /opt/module/sqoop-1.4.7.bin__hadoop-2.6.0/bin/../../accumulo does not exist! Accumulo imports will fail.Please set $ACCUMULO_HOME to the root of your Accumulo installation.20/05/21 07:40:21 INFO sqoop.Sqoop: Running Sqoop version: 1.4.720/05/21 07:40:21 WARN tool.BaseSqoopTool: Setting your password on the command-line is insecure. Consider using -P instead.20/05/21 07:40:21 INFO manager.MySQLManager: Preparing to use a MySQL streaming resultset.information_schemahivemysqlperformance_schematest ​ 当出现如下数据库表示连接正常： 123information_schemamysqlperformance_schema","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"Sqoop","slug":"框架/BigData/Sqoop","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/Sqoop/"}],"tags":[{"name":"Sqoop","slug":"Sqoop","permalink":"http://yoursite.com/tags/Sqoop/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"Sqoop","slug":"框架/BigData/Sqoop","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/Sqoop/"}]},{"title":"HBase API","slug":"HBase-API","date":"2020-05-16T14:30:00.000Z","updated":"2020-05-16T15:01:10.274Z","comments":true,"path":"2020/05/16/HBase-API/","link":"","permalink":"http://yoursite.com/2020/05/16/HBase-API/","excerpt":"","text":"HBase API 1. 环境准备 新建项目后在 pom.xml 中添加依赖： 1234567891011121314151617181920212223&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-server&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-client&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; log4j.properties配置文件： 12345678log4j.rootLogger=INFO, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n log4j.appender.logfile=org.apache.log4j.FileAppender log4j.appender.logfile.File=target/hbase.log log4j.appender.logfile.layout=org.apache.log4j.PatternLayout log4j.appender.logfile.layout.ConversionPattern=%d %p [%c] - %m%n 编写测试代码","categories":[],"tags":[],"keywords":[]},{"title":"Markdown 编辑器 Typora 支持SM.MS图床功能","slug":"Markdown编辑器-Typora-支持SM-MS图床功能","date":"2020-05-15T06:30:08.000Z","updated":"2020-05-15T06:52:48.438Z","comments":true,"path":"2020/05/15/Markdown编辑器-Typora-支持SM-MS图床功能/","link":"","permalink":"http://yoursite.com/2020/05/15/Markdown%E7%BC%96%E8%BE%91%E5%99%A8-Typora-%E6%94%AF%E6%8C%81SM-MS%E5%9B%BE%E5%BA%8A%E5%8A%9F%E8%83%BD/","excerpt":"","text":"Markdown 编辑器 Typora 支持SM.MS图床功能 调整typora设置 1、确保typora的版本在0.9.86以上 2、打开typora，点开最上面的帮助，点击里面的检测更新，先升级一下版本，确保能用。 3、接着点开 最上面的文件，点倒数第二个偏好设置 4、点击图像 5、按照下图，进行选择 6、点击下载或更新 注册smms，获取token 1、复制下面这条链接，并注册账号 https://sm.ms/home/apitoken 2、登录你注册的账号（注意用户名是用户名，不是邮箱），接着复制下面的链接，再次访问 https://sm.ms/home/apitoken 3、然后，你就进入到这个页面 4、回到你的typora，点击打开配置文件 5、将下面代码复制粘贴到你的配置文件中 123456789&#123; \"picBed\": &#123; \"uploader\": \"smms\", // 代表当前的默认上传图床为 SM.MS, \"smms\": &#123; \"token\": \"这里面的token换成你上个页面的申请的token\" //一定要换 &#125; &#125;, \"picgoPlugins\": &#123;&#125; // 为插件预留&#125; 6、保存这个json文件 7、点开验证图片上传 测试一下 大功告成！！！","categories":[{"name":"Typora","slug":"Typora","permalink":"http://yoursite.com/categories/Typora/"},{"name":"Markdown","slug":"Typora/Markdown","permalink":"http://yoursite.com/categories/Typora/Markdown/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"http://yoursite.com/tags/Typora/"},{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}],"keywords":[{"name":"Typora","slug":"Typora","permalink":"http://yoursite.com/categories/Typora/"},{"name":"Markdown","slug":"Typora/Markdown","permalink":"http://yoursite.com/categories/Typora/Markdown/"}]},{"title":"Python 学习","slug":"Python-学习","date":"2020-05-13T09:20:02.000Z","updated":"2020-05-13T09:20:02.141Z","comments":true,"path":"2020/05/13/Python-学习/","link":"","permalink":"http://yoursite.com/2020/05/13/Python-%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"HBase Shell操作","slug":"HBase-Shell操作","date":"2020-05-12T14:43:27.000Z","updated":"2020-05-13T03:01:49.681Z","comments":true,"path":"2020/05/12/HBase-Shell操作/","link":"","permalink":"http://yoursite.com/2020/05/12/HBase-Shell%E6%93%8D%E4%BD%9C/","excerpt":"","text":"HBase Shell操作 基本操作 进入 HBase 客户端命令： [root@hadoop141 hbase]$ bin/hbase shell 查看帮助命令 hbase(main):001:0&gt; help 查看当前数据库中有哪些表 hbase(main):002:0&gt; list 表的操作 创建表 hbase(main):002:0&gt; create 'student','info' 插入数据到表 12345hbase(main):003:0&gt; put 'student','1001','info:sex','male'hbase(main):004:0&gt; put 'student','1001','info:age','18'hbase(main):005:0&gt; put 'student','1002','info:name','Janna'hbase(main):006:0&gt; put 'student','1002','info:sex','female'hbase(main):007:0&gt; put 'student','1002','info:age','20' 12345put 'student','1001','info:sex','male'put 'student','1001','info:age','18'put 'student','1002','info:name','Janna'put 'student','1002','info:sex','female'put 'student','1002','info:age','20' 扫描查看表数据 123hbase(main):008:0&gt; scan 'student'hbase(main):009:0&gt; scan 'student',&#123;STARTROW =&gt; '1001', STOPROW =&gt; '1001'&#125;hbase(main):010:0&gt; scan 'student',&#123;STARTROW =&gt; '1001'&#125; 查看表结构 hbase(main):011:0&gt; describe 'student' 更新指定字段的数据 12hbase(main):012:0&gt; put 'student','1001','info:name','Nick'hbase(main):013:0&gt; put 'student','1001','info:age','100' 查看“指定行”或“指定列族:列”的数据 12hbase(main):014:0&gt; get 'student','1001'hbase(main):015:0&gt; get 'student','1001','info:name' 统计表数据行数 hbase(main):021:0&gt; count 'student' 删除数据 删除某rowkey的全部数据： hbase(main):016:0&gt; deleteall 'student','1001' 删除某rowkey的某一列数据： hbase(main):017:0&gt; delete 'student','1002','info:sex' 清空表数据 hbase(main):018:0&gt; truncate 'student' 提示： 清空表的操作顺序为先disable，然后再truncate。 删除表 首先需要先让该表为disable状态： hbase(main):019:0&gt; disable 'student' 然后才能drop这个表： hbase(main):020:0&gt; drop 'student' 提示： 如果直接drop表，会报错：ERROR: Table student is enabled. Disable it first. 变更表信息 将info列族中的数据存放3个版本： 12hbase(main):022:0&gt; alter 'student',&#123;NAME=&gt;'info',VERSIONS=&gt;3&#125;hbase(main):022:0&gt; get 'student','1001',&#123;COLUMN=&gt;'info:name',VERSIONS=&gt;3&#125;","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"HBase","slug":"框架/BigData/HBase","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/HBase/"}],"tags":[{"name":"HBase","slug":"HBase","permalink":"http://yoursite.com/tags/HBase/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"HBase","slug":"框架/BigData/HBase","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/HBase/"}]},{"title":"HBase 安装","slug":"HBase-安装","date":"2020-05-12T13:52:17.000Z","updated":"2020-05-13T03:01:55.390Z","comments":true,"path":"2020/05/12/HBase-安装/","link":"","permalink":"http://yoursite.com/2020/05/12/HBase-%E5%AE%89%E8%A3%85/","excerpt":"","text":"HBase 安装 启动 zookeeper a. 进入 zookeeper 目录： /opt/module/zookeeper-3.4.10 b. 启动 zookeeper 命令： 1bin/zkServer.sh start 启动 Hadoop a. 进入 Hadoop 目录： /opt/module/hadoop-2.7.2 b. 启动 DFS 命令： 1sbin/start-dfs.sh c. Yarn 可以不要启动 1sbin/start-yarn.sh HBase 的解压 解压 HBase 到指定目录： 1[root@hadoop141 software]$ tar -zxvf hbase-1.3.1-bin.tar.gz -C /opt/module 修改 HBase 的配置文件 a. /opt/module/hbase-1.3.1/conf/hbase-env.sh 修改内容： 12345678910111. 添加环境变量：export JAVA_HOME=/opt/module/jdk1.8.0_144export HBASE_MANAGES_ZK=false2. JDK1.8需要注释#export HBASE_MASTER_OPTS...#export HBASE_REGIONSERVER_OPTS...3. 修改 HBASE_PID_DIR # The directory where pid files are stored. /tmp by default.export HBASE_PID_DIR=/opt/module/hbase-1.3.1/pids 注意 还需要修改 HBASE_PID_DIR 内容，如果不修改会报stopping hbasecat: /tmp/hbase-root-master.pid: No such file or directory错误， 因为默认路径是在 /tmp 目录下，而 /tmp 目录不稳定很容易丢失，造成停止集群的时候出现上述错误。 解决方式是在hbase-env.sh中修改pid文件的存放路径。 b. /opt/module/hbase-1.3.1/conf/hbase-site.xml 修改内容： 123456789101112131415161718192021222324252627&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://hadoop141:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;!-- 0.98后的新变动，之前版本没有.port,默认端口为60000 --&gt; &lt;property&gt; &lt;name&gt;hbase.master.port&lt;/name&gt; &lt;value&gt;16000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;hadoop141:2181,hadoop142:2181,hadoop143:2181&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/opt/module/zookeeper-3.4.10/zkData&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; c. /opt/module/hbase-1.3.1/conf/regionservers 的修改： 添加你的集群： 123hadoop141hadoop142hadoop143 d. 软连接hadoop配置文件到hbase： 1234[root@hadoop141 module]$ ln -s /opt/module/hadoop-2.7.2/etc/hadoop/core-site.xml /opt/module/hbase-1.3.1/conf/core-site.xml[root@hadoop141 module]$ ln -s /opt/module/hadoop-2.7.2/etc/hadoop/hdfs-site.xml /opt/module/hbase-1.3.1/conf/hdfs-site.xml HBase远程发送到其他集群 1[root@hadoop141 module]# xrsync.sh hbase-1.3.1/ 远程分发脚本：xrsync.sh 12345678910111213141516171819202122232425#!/bin/bash#1 获取输入参数个数，如果没有参数，直接退出pcount=$#if ((pcount==0)); thenecho no args;exit;fi#2 获取文件名称p1=$1fname=`basename $p1`echo fname=$fname#3 获取上级目录的对路径pdir=`cd -P $(dirname $p1); pwd`echo pdir=$pdir#4 获取当前用户名称user=`whoami`#5 循环for((host=140; host&lt;143; host++)); do echo ------------------- hadoop$host -------------- rsync -av $pdir/$fname $user@hadoop$host:$pdirdone HBase服务的启动 注意：启动前必须做好 同步时间服务 启动服务命令： 1[root@hadoop141 hbase]$ bin/start-hbase.sh 停止服务命令： 1[root@hadoop141 hbase]$ bin/stop-hbase.sh 查看HBase页面 a. 启动成功： 12345678910111213141516171819[root@hadoop141 module]# xcall.sh jps============= hadoop141 jps =============12611 Jps7495 HRegionServer8650 HMaster3066 QuorumPeerMain2636 NameNode2751 DataNode============= hadoop142 jps =============9361 Jps2516 DataNode5596 HRegionServer2636 QuorumPeerMain============= hadoop143 jps =============2513 DataNode10662 Jps6250 HRegionServer2589 SecondaryNameNode2717 QuorumPeerMain b. 启动成功后，可以通过“host:port”的方式来访问HBase管理页面，例如： http://hadoop141:16010","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"HBase","slug":"框架/BigData/HBase","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/HBase/"}],"tags":[{"name":"HBase","slug":"HBase","permalink":"http://yoursite.com/tags/HBase/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"HBase","slug":"框架/BigData/HBase","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/HBase/"}]},{"title":"HBase 简介","slug":"Hbase-简介","date":"2020-05-12T12:32:23.000Z","updated":"2020-05-13T08:45:44.201Z","comments":true,"path":"2020/05/12/Hbase-简介/","link":"","permalink":"http://yoursite.com/2020/05/12/Hbase-%E7%AE%80%E4%BB%8B/","excerpt":"","text":"HBase 简介 什么是Hbase Google曾经发表过三篇论文： 1. GFS：Google File System --&gt; HDFS 对数据进行分布式文件系统的存储，解决的大数据的存储问题; 2. MapReduce --&gt; Yarn 最初是因为Google要去爬取全球的网页然后对其进行排名(PageRank)而衍生出的问题，一种用于大数据计算的模型，核心思想是大事化小处理，最后在合并结果，先拆分再合并; 3. BigTable --&gt; HBase 采用NoSQL数据库将数据存在一张大表之中，通过牺牲存储的空间来换取性能. 可以看出 HBase 的原型就是 BigTable 论文，受到了该论文思想的启发，目前作为Hadoop的子项目来开发维护，用于支持结构化的数据存储。 官方网站：http://hbase.apache.org – 2006年Google发表BigTable白皮书 – 2006年开始开发HBase – 2008年北京成功开奥运会，程序员默默地将HBase弄成了Hadoop的子项目 – 2010年HBase成为Apache顶级项目 – 现在很多公司二次开发出了很多发行版本，你也开始使用了。 HBase HBase 是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统色，利用HBASE技术可在廉价PC Server上搭建起大规模结构化存储集群。 HBase 特点 海量存储 HBase 适合存储PB级别的海量数据，在PB级别的数据以及采用廉价PC存储的情况下，能在几十到百毫秒内返回数据。这与Hbase的极易扩展性息息相关。正式因为Hbase良好的扩展性，才为海量数据的存储提供了便利。 列式存储 这里的列式存储其实说的是列族（ColumnFamily）存储，Hbase是根据列族来存储数据的。列族下面可以有非常多的列，列族在创建表的时候就必须指定。 极易扩展 Hbase的扩展性主要体现在两个方面，一个是基于上层处理能力（RegionServer）的扩展，一个是基于存储的扩展（HDFS）。 通过横向添加RegionSever的机器，进行水平扩展，提升Hbase上层的处理能力，提升Hbsae服务更多Region的能力。 备注：RegionServer的作用是管理region、承接业务的访问，这个后面会详细的介绍通过横向添加Datanode的机器，进行存储层扩容，提升Hbase的数据存储能力和提升后端存储的读写能力。 高并发（多核） 由于目前大部分使用Hbase的架构，都是采用的廉价PC，因此单个IO的延迟其实并不小，一般在几十到上百ms之间。这里说的高并发，主要是在并发的情况下，Hbase的单个IO延迟下降并不多。能获得高并发、低延迟的服务。 稀疏 稀疏主要是针对Hbase列的灵活性，在列族中，你可以指定任意多的列，在列数据为空的情况下，是不会占用存储空间的。 HBase 架构 Hbase架构图： 从图中可以看出Hbase是由Client、Zookeeper、Master、HRegionServer、HDFS等几个组件组成，下面来介绍一下几个组件的相关功能： Client ​ Client包含了访问Hbase的接口，另外Client还维护了对应的cache来加速Hbase的访问，比如cache的.META.元数据的信息。 Zookeeper ​ HBase通过Zookeeper来做master的高可用、RegionServer的监控、元数据的入口以及集群配置的维护等工作。具体工作如下： ​ 通过Zoopkeeper来保证集群中只有1个master在运行，如果master异常，会通过竞争机制产生新的master提供服务 ​ 通过Zoopkeeper来监控RegionServer的状态，当RegionSevrer有异常的时候，通过回调的形式通知Master RegionServer上下线的信息 ​ 通过Zoopkeeper存储元数据的统一入口地址 Hmaster（NameNode） ​ master节点的主要职责如下： 为RegionServer分配Region 维护整个集群的负载均衡 维护集群的元数据信息 发现失效的Region，并将失效的Region分配到正常的RegionServer上 当RegionSever失效的时候，协调对应Hlog的拆分 HregionServer(DataNode) ​ HregionServer直接对接用户的读写请求**，是真正的“干活”的节点。它的功能概括如下： 管理master为其分配的Region 处理来自客户端的读写请求 负责和底层HDFS的交互，存储数据到HDFS 负责Region变大以后的拆分 负责Storefile的合并工作 HDFS ​ HDFS为Hbase提供最终的底层数据存储服务，同时为HBase提供高可用（Hlog存储在HDFS）的支持，具体功能概括如下： 提供元数据和表数据的底层分布式存储服务 数据多副本，保证的高可靠和高可用性 HBase中的角色 HMaster 功能 监控RegionServer 处理RegionServer故障转移 处理元数据的变更 处理region的分配或转移 在空闲时间进行数据的负载均衡 通过Zookeeper发布自己的位置给客户端 RegionServer 功能 负责存储HBase的实际数据 处理分配给它的Region 刷新缓存到HDFS 维护Hlog 执行压缩 负责处理Region分片 其他组件 Write-Ahead logs HBase的修改记录，当对HBase读写数据的时候，数据不是直接写进磁盘，它会在内存中保留一段时间（时间以及数据量阈值可以设定）。但把数据保存在内存中可能有更高的概率引起数据丢失，为了解决这个问题，数据会先写在一个叫做Write-Ahead logfile的文件中，然后再写入内存中。所以在系统出现故障的时候，数据可以通过这个日志文件重建。 Region Hbase表的分片，HBase表会根据RowKey值被切分成不同的region存储在RegionServer中，在一个RegionServer中可以有多个不同的region。 Store HFile存储在Store中，一个Store对应HBase表中的一个列族(列簇， Column Family)。 MemStore 顾名思义，就是内存存储，位于内存中，用来保存当前的数据操作，所以当数据保存在WAL中之后，RegsionServer会在内存中存储键值对。 File 这是在磁盘上保存原始数据的实际的物理文件，是实际的存储文件。StoreFile是以Hfile的形式存储在HDFS的。 ​ ​ ​ ​ ​ ​ ​ ​","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"HBase","slug":"框架/BigData/HBase","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/HBase/"}],"tags":[{"name":"HBase","slug":"HBase","permalink":"http://yoursite.com/tags/HBase/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"HBase","slug":"框架/BigData/HBase","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/HBase/"}]},{"title":"Kafka-Consumer-API","slug":"Kafka-Consumer-API","date":"2020-05-11T14:25:26.000Z","updated":"2020-05-11T14:34:46.163Z","comments":true,"path":"2020/05/11/Kafka-Consumer-API/","link":"","permalink":"http://yoursite.com/2020/05/11/Kafka-Consumer-API/","excerpt":"","text":"Kafka-Consumer-API 消费者 API 测试 导入依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt; &lt;version&gt;0.11.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 需要用到的类: KafkaConsumer：需要创建一个消费者对象，用来消费数据 ConsumerConfig：获取所需的一系列配置参数 ConsuemrRecord：每条数据都要封装成一个ConsumerRecord对象 自动提交offset 为了使我们能够专注于自己的业务逻辑，Kafka提供了自动提交offset的功能。 自动提交offset的相关参数： enable.auto.commit：是否开启自动提交offset功能 – true auto.commit.interval.ms：自动提交offset的时间间隔 测试代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package codes.coffeecode.kafka.consumer;import org.apache.kafka.clients.consumer.ConsumerConfig;import org.apache.kafka.clients.consumer.ConsumerRecord;import org.apache.kafka.clients.consumer.ConsumerRecords;import org.apache.kafka.clients.consumer.KafkaConsumer;import java.util.Arrays;import java.util.Properties;/** * Consumer API * 需要用到的类： * KafkaConsumer：需要创建一个消费者对象，用来消费数据 * ConsumerConfig：获取所需的一系列配置参数 * ConsuemrRecord：每条数据都要封装成一个ConsumerRecord对象 */public class CustomConsumer &#123; public static void main(String[] args) &#123; //1.创建消费者配置信息 Properties properties = new Properties(); //2. 给配置信息赋值 //连接的集群 properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,\"hadoop141:9092\"); //自动提交 properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,\"true\"); //提交延时 properties.put(ConsumerConfig.CONNECTIONS_MAX_IDLE_MS_CONFIG,\"1000\"); //key、value反序列化 properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,\"org.apache.kafka.common.serialization.StringDeserializer\"); properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,\"org.apache.kafka.common.serialization.StringDeserializer\"); //消费者组 properties.put(ConsumerConfig.GROUP_ID_CONFIG,\"test\"); //创建消费者 KafkaConsumer&lt;String,String&gt; consumer = new KafkaConsumer&lt;String, String&gt;(properties); //订阅主题 //可以订阅多个主题 consumer.subscribe(Arrays.asList(\"bigdata\",\"bigdata2\")); //解析并打印consumerRecords while (true)&#123; //获取数据 ConsumerRecords&lt;String, String&gt; consumerRecords = consumer.poll(100); for (ConsumerRecord&lt;String, String&gt; con:consumerRecords ) &#123; System.out.println(con.key()+\"--\"+con.value()); &#125; &#125; &#125;&#125; 手动提交offset Kafka提供了手动提交offset的功能。 手动提交offset的相关参数： enable.auto.commit：是否开启自动提交offset功能 – false consumer.commitSync()：同步提交 测试代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package codes.coffeecode.kafka.consumer;import org.apache.kafka.clients.consumer.ConsumerConfig;import org.apache.kafka.clients.consumer.ConsumerRecord;import org.apache.kafka.clients.consumer.ConsumerRecords;import org.apache.kafka.clients.consumer.KafkaConsumer;import java.util.Arrays;import java.util.Properties;/** * Consumer API * 需要用到的类： * KafkaConsumer：需要创建一个消费者对象，用来消费数据 * ConsumerConfig：获取所需的一系列配置参数 * ConsuemrRecord：每条数据都要封装成一个ConsumerRecord对象 */public class CustomConsumer &#123; public static void main(String[] args) &#123; //1.创建消费者配置信息 Properties properties = new Properties(); //2. 给配置信息赋值 //连接的集群 properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,\"hadoop141:9092\"); //自动提交 properties.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG,\"false\"); //key、value反序列化 properties.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG,\"org.apache.kafka.common.serialization.StringDeserializer\"); properties.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,\"org.apache.kafka.common.serialization.StringDeserializer\"); //消费者组 properties.put(ConsumerConfig.GROUP_ID_CONFIG,\"test\"); //创建消费者 KafkaConsumer&lt;String,String&gt; consumer = new KafkaConsumer&lt;String, String&gt;(properties); //订阅主题 //可以订阅多个主题 consumer.subscribe(Arrays.asList(\"bigdata\",\"bigdata2\")); //解析并打印consumerRecords while (true)&#123; //获取数据 ConsumerRecords&lt;String, String&gt; consumerRecords = consumer.poll(100); for (ConsumerRecord&lt;String, String&gt; con:consumerRecords ) &#123; System.out.println(con.key()+\"--\"+con.value()); &#125; consumer.commitSync(); &#125; &#125;&#125; 代码分析 手动提交offset的方法有两种： 分别是commitSync（同步提交）和commitAsync（异步提交）。 两者的相同点是，都会将本次poll的一批数据最高的偏移量提交； 不同点是，commitSync会失败重试，一直到提交成功（如果由于不可恢复原因导致，也会提交失败）； 而commitAsync则没有失败重试机制，故有可能提交失败。","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"Kafka","slug":"框架/BigData/Kafka","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/Kafka/"}],"tags":[{"name":"Kafka","slug":"Kafka","permalink":"http://yoursite.com/tags/Kafka/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"Kafka","slug":"框架/BigData/Kafka","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/Kafka/"}]},{"title":"Kafka API 同步发送","slug":"Kafka-API-同步发送","date":"2020-05-11T13:37:44.000Z","updated":"2020-05-11T13:56:30.380Z","comments":true,"path":"2020/05/11/Kafka-API-同步发送/","link":"","permalink":"http://yoursite.com/2020/05/11/Kafka-API-%E5%90%8C%E6%AD%A5%E5%8F%91%E9%80%81/","excerpt":"","text":"Kafka API 同步发送 同步发送 同步发送的意思就是，一条消息发送之后，会阻塞当前线程，直至返回ack。 由于send方法返回的是一个Future对象，根据Futrue对象的特点，我们也可以实现同步发送的效果，只需在调用Future对象的get方发即可。 启动zookeeper和Kafka服务 123456789101112============= hadoop141 jps =============3218 Jps2538 QuorumPeerMain3180 Kafka============= hadoop142 jps =============3184 Jps3094 Kafka2490 QuorumPeerMain============= hadoop143 jps =============3193 Jps3100 Kafka2492 QuorumPeerMain 编写测试代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package codes.coffeecode.kafka.producer;import org.apache.kafka.clients.producer.KafkaProducer;import org.apache.kafka.clients.producer.Producer;import org.apache.kafka.clients.producer.ProducerConfig;import org.apache.kafka.clients.producer.ProducerRecord;import java.util.Properties;import java.util.concurrent.ExecutionException;/** * 同步发送API * 同步发送的意思就是，一条消息发送之后，会阻塞当前线程，直至返回ack。 * 由于send方法返回的是一个Future对象，根据Futrue对象的特点，我们也可以实现同步发送的效果，只需在调用Future对象的get方发即可。 */public class SyncCustomProducer &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //1. 创建Kafka生产者的配置信息 Properties properties = new Properties(); //2. 指定连接的Kafka集群 broker-list //ProducerConfig.BOOTSTRAP_SERVERS_CONFIG -- \"bootstrap.servers\" properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,\"hadoop141:9092\"); //3. ACK应答级别 //ProducerConfig.ACKS_CONFIG -- \"acks\" properties.put(ProducerConfig.ACKS_CONFIG,\"all\"); //4. 重试次数 //ProducerConfig.RETRIES_CONFIG -- \"retries\" properties.put(ProducerConfig.RETRIES_CONFIG,1); //5. 批次大小 16k properties.put(\"batch.size\",16384); //6. 等待时间 1ms properties.put(\"linger.ms\",1); //7. Record Accumulator 缓冲区大小 32M properties.put(\"buffer.memory\", 33554432); //8. key、value的序列化类 properties.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\"); properties.put(\"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\"); //9. 创建生产者对象 Producer&lt;String,String&gt; producer = new KafkaProducer&lt;String, String&gt;(properties); //10. 发送数据 for (int i = 0; i &lt; 10 ; i++)&#123; producer.send(new ProducerRecord&lt;String, String&gt;(\"bigdata\",\"CustomProducer--\"+i)).get(); &#125; //11. 关闭资源 producer.close(); &#125;&#125; 启动bigdata消费者 1[root@hadoop141 kafka]# bin/kafka-console-consumer.sh --bootstrap-server hadoop141:9092 --from-beginning --topic bigdata 运行程序 消费者显示结果： 12345678910CustomProducer--0CustomProducer--1CustomProducer--2CustomProducer--3CustomProducer--4CustomProducer--5CustomProducer--6CustomProducer--7CustomProducer--8CustomProducer--9","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"Kafka","slug":"框架/BigData/Kafka","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/Kafka/"}],"tags":[{"name":"Kafka","slug":"Kafka","permalink":"http://yoursite.com/tags/Kafka/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"Kafka","slug":"框架/BigData/Kafka","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/Kafka/"}]},{"title":"hexo 思维导图插件：hexo-simple-mindmap","slug":"hexo-思维导图插件：hexo-simple-mindmap","date":"2020-05-10T07:31:29.000Z","updated":"2020-05-10T07:46:12.338Z","comments":true,"path":"2020/05/10/hexo-思维导图插件：hexo-simple-mindmap/","link":"","permalink":"http://yoursite.com/2020/05/10/hexo-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E6%8F%92%E4%BB%B6%EF%BC%9Ahexo-simple-mindmap/","excerpt":"","text":"hexo 思维导图插件：hexo-simple-mindmap 使用方法 先进入Hexo博客的根目录，执行npm install hexo-simple-mindmap安装插件。 测试： 12345678910&#123;% pullquote mindmap mindmap-md %&#125;- [Hexo 的思维导图插件](https://hunterx.xyz/hexo-simple-mindmap-plugin-intro.html) - 前言 - 使用方法 - 一 - 二 - 三 - 太长不看 - 参考资料&#123;% endpullquote %&#125; 显示效果 Hexo 的思维导图插件 前言 使用方法 一 二 三 太长不看 参考资料","categories":[],"tags":[],"keywords":[]},{"title":"Kafka API 异步发送","slug":"Kafka-API-异步发送","date":"2020-05-09T12:30:32.000Z","updated":"2020-05-11T13:37:42.933Z","comments":true,"path":"2020/05/09/Kafka-API-异步发送/","link":"","permalink":"http://yoursite.com/2020/05/09/Kafka-API-%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81/","excerpt":"","text":"Kafka API 异步发送 Producer API 消息发送流程 Kafka的Producer发送消息采用的是异步发送的方式。在消息发送的过程中，涉及到了两个线程——main线程和Sender线程，以及一个线程共享变量——RecordAccumulator。main线程将消息发送给RecordAccumulator，Sender线程不断从RecordAccumulator中拉取消息发送到Kafka broker。 相关参数 batch.size：只有数据积累到batch.size之后，sender才会发送数据。 linger.ms：如果数据迟迟未达到batch.size，sender等待linger.time之后就会发送数据。 异步发送 导入依赖 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt; &lt;artifactId&gt;kafka-clients&lt;/artifactId&gt; &lt;version&gt;0.11.0.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写代码 相关类： KafkaProducer：需要创建一个生产者对象，用来发送对象； ProducerConfig：获取所需的一系列配置参数； ProducerRecord：每条数据都要分装成一个ProducerRecord对象。 不带回调函数的API 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package codes.coffeecode.kafka.producer;import org.apache.kafka.clients.producer.*;import java.util.Properties;/** * 不带回调函数的API */public class CustomProducer &#123; public static void main(String[] args) &#123; //1. 创建Kafka生产者的配置信息 Properties properties = new Properties(); //2. 指定连接的Kafka集群 broker-list //ProducerConfig.BOOTSTRAP_SERVERS_CONFIG -- \"bootstrap.servers\" properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,\"hadoop141:9092\"); //3. ACK应答级别 //ProducerConfig.ACKS_CONFIG -- \"acks\" properties.put(ProducerConfig.ACKS_CONFIG,\"all\"); //4. 重试次数 //ProducerConfig.RETRIES_CONFIG -- \"retries\" properties.put(ProducerConfig.RETRIES_CONFIG,1); //5. 批次大小 16k properties.put(\"batch.size\",16384); //6. 等待时间 1ms properties.put(\"linger.ms\",1); //7. Record Accumulator 缓冲区大小 32M properties.put(\"buffer.memory\", 33554432); //8. key、value的序列化类 properties.put(\"key.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\"); properties.put(\"value.serializer\", \"org.apache.kafka.common.serialization.StringSerializer\"); //9. 创建生产者对象 Producer&lt;String,String&gt; producer = new KafkaProducer&lt;String, String&gt;(properties); //10. 发送数据 for (int i = 0; i &lt; 10 ; i++)&#123; producer.send(new ProducerRecord&lt;String, String&gt;(\"bigdata\",\"CustomProducer--\"+i)); &#125; //11. 关闭资源 producer.close(); &#125;&#125; 带回调函数的API 回调函数会在producer收到ack时调用，为异步调用，该方法有两个参数，分别是RecordMetadata和Exception，如果Exception为null，说明消息发送成功，如果Exception不为null，说明消息发送失败。 注意：消息发送失败会自动重试，不需要我们在回调函数中手动重试。 1234567891011121314151617181920212223242526272829303132333435363738package codes.coffeecode.kafka.producer;import org.apache.kafka.clients.producer.*;import java.util.Properties;/** * 回调函数的API */public class CallBackProducer &#123; public static void main(String[] args) &#123; //1. 创建生产者配置信息 Properties properties = new Properties(); properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,\"hadoop141:9092\"); properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,\"org.apache.kafka.common.serialization.StringSerializer\"); properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,\"org.apache.kafka.common.serialization.StringSerializer\"); //2. 创建生产者对象 KafkaProducer&lt;String,String&gt; producer = new KafkaProducer&lt;String, String&gt;(properties); //3. 发送数据 for (int i = 0; i &lt; 10; i++) &#123; producer.send(new ProducerRecord&lt;String, String&gt;(\"test\",\"CallBack--\" + i), new Callback() &#123; public void onCompletion(RecordMetadata metadata, Exception exception) &#123; if (exception == null)&#123; System.out.println(metadata.partition()+\"==\"+metadata.offset()); &#125;else &#123; exception.printStackTrace(); &#125; &#125; &#125;); &#125; //4. 关闭资源 producer.close(); &#125;&#125; 自定义Partitions 实现接口org.apache.kafka.clients.producer.Partitioner 自定义分区器代码 123456789101112131415161718192021222324package codes.coffeecode.kafka.partitions;import org.apache.kafka.clients.producer.Partitioner;import org.apache.kafka.common.Cluster;import java.util.Map;/** * 自定义分区器 */public class MyPartitions implements Partitioner &#123; public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) &#123; //自定义分区到2号分区 return 2; &#125; public void close() &#123; &#125; public void configure(Map&lt;String, ?&gt; configs) &#123; &#125;&#125; 生产者代码 1234567891011121314151617181920212223242526272829303132333435363738package codes.coffeecode.kafka.producer;import org.apache.kafka.clients.producer.*;import java.util.Properties;public class PartitionProducer &#123; public static void main(String[] args) &#123; //1. 创建生产者配置信息 Properties properties = new Properties(); properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,\"hadoop141:9092\"); properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,\"org.apache.kafka.common.serialization.StringSerializer\"); properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,\"org.apache.kafka.common.serialization.StringSerializer\"); // 添加自定义分区器 properties.put(ProducerConfig.PARTITIONER_CLASS_CONFIG,\"codes.coffeecode.kafka.partitions.MyPartitions\"); //2. 创建生产者对象 KafkaProducer&lt;String,String&gt; producer = new KafkaProducer&lt;String, String&gt;(properties); //3. 发送数据 for (int i = 0; i &lt; 10; i++) &#123; producer.send(new ProducerRecord&lt;String, String&gt;(\"test\",\"CallBack--\" + i), new Callback() &#123; public void onCompletion(RecordMetadata metadata, Exception exception) &#123; if (exception == null)&#123; System.out.println(metadata.partition()+\"==\"+metadata.offset()); &#125;else &#123; exception.printStackTrace(); &#125; &#125; &#125;); &#125; //4. 关闭资源 producer.close(); &#125;&#125; 结果 123456789102==92==102==112==122==132==142==152==162==172==18","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"Kafka","slug":"框架/BigData/Kafka","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/Kafka/"}],"tags":[{"name":"Kafka","slug":"Kafka","permalink":"http://yoursite.com/tags/Kafka/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"Kafka","slug":"框架/BigData/Kafka","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/Kafka/"}]},{"title":"Python 计算生态概览","slug":"Python 计算生态概览","date":"2020-05-08T09:18:45.000Z","updated":"2020-05-08T11:18:30.081Z","comments":true,"path":"2020/05/08/Python 计算生态概览/","link":"","permalink":"http://yoursite.com/2020/05/08/Python%20%E8%AE%A1%E7%AE%97%E7%94%9F%E6%80%81%E6%A6%82%E8%A7%88/","excerpt":"","text":"Python 计算生态概览 Python 计算程序设计思维 计算思维：抽象计算过程和自动化执行 计算生态：竞争发展、相互依存、快速更迭 用户体验：进度展示、异常处理等 IPO、自顶向下、模块化、配置化、应用开发的四个步骤 Python 计算生态概览 从数据处理到人工智能 从Web解析到网络空间 从人机交互到艺术设计 从数据处理到人工智能 数据表示-&gt;数据清洗-&gt;数据统计-&gt;数据可视化-&gt;数据挖掘-&gt;人工智能 数据表示：采用合适方式用程序表达数据 数据清理：数据归一化、数据转换、异常值处理 数据统计：数据的概要理解，数量、分布、中位数等 数据可视化：直观展示数据内涵的方式 数据挖掘：从数据分析获得知识，产生数据外的价值 人工智能：数据/语言/图像/视觉等方面深度分析与决策 主要库： Python库之数据分析 Python库之数据可视化 Python库之文本处理 Python库之机器学习 Python库之数据分析 Numpy: 表达N维数组的最基础库 Python接口使用， C语言实现，计算速度优异 Python数据分析及科学计算的基础库，支撑Pandas等 提供直接的矩阵运算、广播函数、线性代数等功能 实例： Numpy: 表达N维数组的最基础库 官网：http://www.numpy.org Pandas: Python数据分析高层次应用库 提供了简单易用的数据结构和数据分析工具 理解数据类型与索引的关系，操作索引即操作数据 Python最主要的数据分析功能库，基于Numpy开发 实例： Pandas: Python数据分析高层次应用库 Series = 索引 + 一维数据 DataFrame = 行列索引 + 二维数据 官网：www.pandas.pydata.org SciPy: 数学、科学和工程计算功能库 提供了一批数学算法及工程数据运算功能 类似Matlab，可用于如傅里叶变换、信号处理等应用 Python最主要的科学计算功能库，基于Numpy开发 实例： SciPy: 数学、科学和工程相关功能库 官网：www.scipy.org Python库之数据可视化 Matplotlib: 高质量的二维数据可视化功能库 提供了超过100种数据可视化展示效果 通过matplotlib.pyplot子库调用各可视化效果 Python最主要的数据可视化功能库，基于Numpy开发 官网：http://matplotlib.org Seaborn: 统计类数据可视化功能库 提供了一批高层次的统计类数据可视化展示效果 主要展示数据间分布、分类和线性关系等内容 基于Matplotlib开发，支持Numpy和Pandas 实例： Seaborn: 统计类数据可视化功能库 官网：http://seaborn.pydata.org Mayavi：三维科学数据可视化功能库 提供了一批简单易用的3D科学计算数据可视化展示效果 目前版本是Mayavi2，三维可视化最主要的第三方库 支持Numpy、 TVTK、 Traits、 Envisage等第三方库 实例： Mayavi：三维科学数据可视化功能库 官网：http://docs.enthought.com/mayavi/mayavi/ Python库之文本处理 PyPDF2： 用来处理pdf文件的工具集 提供了一批处理PDF文件的计算功能 支持获取信息、分隔/整合文件、加密解密等 完全Python语言实现，不需要额外依赖，功能稳定 实例： 两个PDF整合 1234567891011from PyPDF2 import PdfFileReader, PdfFileMergermerger = PdfFileMerger()input1 = open(\"document1.pdf\",\"rb\")input2 = open(\"document2.pdf\",\"rb\")merger.append(fileobj = input1, pages = (0,3))merger.merge(position = 2, fileobj = input2, pages = (0,1))output = open(\"document-output.pdf\",\"wb\")merger.write(output) 官网：http://mstamy2.github.io/PyPDF2/ NLTK： 自然语言文本处理第三方库 提供了一批简单易用的自然语言文本处理功能 支持语言文本分类、标记、语法句法、语义分析等 最优秀的Python自然语言处理库 实例： NLTK： 自然语言文本处理第三方库 123from nltk.corpus import treebankt = treebank.parsed_sents('wsj_0001.mrg')[0]t.draw() 官网：http://www.nltk.org/ Python-docx： 创建或更新Microsoft Word文件的第三方库 提供创建或更新.doc .docx等文件的计算功能 增加并配置段落、图片、表格、文字等，功能全面 实例： Python-docx： 创建或更新Microsoft Word文件的第三方库 123456from docx import Documentdocument = Document()document.add_heading('Document Title', 0)p = document.add_paragraph('A plain paragraph having some ')document.add_page_break()document.save('demo.docx') 官网：https://python-docx.readthedocs.io/en/latest/index.html Python库之机器学习 Scikit-learn： 机器学习方法工具集 提供一批统一化的机器学习方法功能接口 提供聚类、分类、回归、强化学习等计算功能 机器学习最基本且最优秀的Python第三方库 实例： Scikit-learn：与数据处理相关的第三方库 官网：http://scijit-learn.org TensorFlow： AlphaGo背后的机器学习计算框架 谷歌公司推动的开源机器学习框架 将数据流图作为基础，图节点代表运算，边代表张量 应用机器学习方法的一种方式，支撑谷歌人工智能应用 官网：https://www.tensorflow.org MXNet：基于神经网络的深度学习计算框架 提供可扩展的神经网络及深度学习计算功能 可用于自动驾驶、机器翻译、语音识别等众多领域 Python最重要的深度学习计算框架 实例： MXNet：基于神经网络的深度学习计算框架 官网：https://mxnet.incubator.apache.org/ 从Web解析到网络空间 Python库之网络爬虫 Python库之Web信息提取 Python库之Web网站开发 Python库之网络应用开发 Python库之网络爬虫 Requests: 最友好的网络爬虫功能库 提供了简单易用的类HTTP协议网络爬虫功能 支持连接池、 SSL、 Cookies、 HTTP(S)代理等 Python最主要的页面级网络爬虫功能库 实例： 1234567import requestsr = requests.get('https://api.github.com/user',auth=('user', 'pass'))r.status_coder.headers['content-type']r.encodingr.text 官网：https://requests.readthedocs.io/en/master/ Scrapy: 优秀的网络爬虫框架 提供了构建网络爬虫系统的框架功能，功能半成品 支持批量和定时网页爬取、提供数据处理流程等 Python最主要且最专业的网络爬虫框架 官网：https://scrapy.org/ pyspider: 强大的Web页面爬取系统 提供了完整的网页爬取系统构建功能 支持数据库后端、消息队列、优先级、分布式架构等 Python重要的网络爬虫类第三方库 官网：http://docs.pyspider.org/en/latest/ Python库之Web信息提取 Beautiful Soup: HTML和XML的解析库 提供了解析HTML和XML等Web信息的功能 又名beautifulsoup4或bs4，可以加载多种解析引擎 常与网络爬虫库搭配使用，如Scrapy、 requests等 实例： Beautiful Soup: HTML和XML的解析库 官网：https://www.crummy.com/software/BeautifulSoup/ Re: 正则表达式解析和处理功能库 提供了定义和解析正则表达式的一批通用功能 可用于各类场景，包括定点的Web信息提取 Python最主要的标准库之一，无需安装 官网：https://docs.python.org/3.6/library/re.html Python-Goose: 提取文章类型Web页面的功能库 提供了对Web页面中文章信息/视频等元数据的提取功能 针对特定类型Web页面，应用覆盖面较广 Python最主要的Web信息提取库 官网：https://github.com/grangier/python-goose Python库之Web网站开发 Django: 最流行的Web应用框架 提供了构建Web系统的基本应用框架 MTV模式：模型(model)、模板(Template)、视图(Views) Python最重要的Web应用框架，略微复杂的应用框架 官网：https://www.djangoproject.com/ Pyramid: 规模适中的Web应用框架 提供了简单方便构建Web系统的应用框架 不大不小， 规模适中，适合快速构建并适度扩展类应用 Python产品级Web应用框架，起步简单可扩展性好 官网：https://trypyramid.com/ Flask: Web应用开发微框架 提供了最简单构建Web系统的应用框架 特点是：简单、规模小、快速 Django &gt; Pyramid &gt; Flask 官网：https://dormousehole.readthedocs.io/en/latest/ 官网：https://flask.palletsprojects.com/en/1.1.x/ Python库之网络应用开发 WeRoBot: 微信公众号开发框架 提供了解析微信服务器消息及反馈消息的功能 建立微信机器人的重要技术手段 官网：https://github.com/offu/WeRoBot aip: 百度AI开放平台接口 提供了访问百度AI服务的Python功能接口 语音、人脸、 OCR、 NLP、知识图谱、图像搜索等领域 Python百度AI应用的最主要方式 官网：https://github.com/Baidu-AIP/python-sdk MyQR: 二维码生成第三方库 提供了生成二维码的系列功能 基本二维码、艺术二维码和动态二维码 官网：https://github.com/sylnsfar/qrcode 从人机交互到艺术设计 Python库之图形用户界面 Python库之游戏开发 Python库之虚拟现实 Python库之图形艺术 Python库之图形用户界面 PyQt5: Qt开发框架的Python接口 提供了创建Qt5程序的Python API接口 Qt是非常成熟的跨平台桌面应用开发系统，完备GUI 推荐的Python GUI开发第三方库 官网：https://www.riverbankcomputing.com/software/pyqt wxPython: 跨平台GUI开发框架 提供了专用于Python的跨平台GUI开发框架 理解数据类型与索引的关系，操作索引即操作数据 Python最主要的数据分析功能库，基于Numpy开发 官网：https://www.wxpython.org/ PyGObject: 使用GTK+开发GUI的功能库 提供了整合GTK+、 WebKitGTK+等库的功能 GTK+：跨平台的一种用户图形界面GUI框架 实例： Anaconda采用该库构建GUI 官网：https://pygobject.readthedocs.io/en/latest/ Python库之游戏开发 PyGame: 简单的游戏开发功能库 提供了基于SDL的简单游戏开发功能及实现引擎 理解游戏对外部输入的响应机制及角色构建和交互机制 Python游戏入门最主要的第三方库 官网：https://www.pygame.org/news Panda3D: 开源、跨平台的3D渲染和游戏开发库 一个3D游戏引擎，提供Python和C++两种接口 支持很多先进特性：法线贴图、光泽贴图、卡通渲染等 由迪士尼和卡尼基梅隆大学共同开发 官网：https://www.panda3d.org/ cocos2d: 构建2D游戏和图形界面交互式应用的框架 提供了基于OpenGL的游戏开发图形渲染功能 支持GPU加速， 采用树形结构分层管理游戏对象类型 适用于2D专业级游戏开发 官网：http://python.cocos2d.org/ Python库之虚拟现实 VR Zero: 在树莓派上开发VR应用的Python库 提供大量与VR开发相关的功能 针对树莓派的VR开发库，支持设备小型化，配置简单化 非常适合初学者实践VR开发及应用 官网：https://github.com/WayneKeenan/python-vrzero pyovr: Oculus Rift的Python开发接口 针对Oculus VR设备的Python开发库 基于成熟的VR设备，提供全套文档，工业级应用设备 Python+虚拟现实领域探索的一种思路 官网：https://github.com/cmbruns/pyovr Vizard: 基于Python的通用VR开发引擎 专业的企业级虚拟现实开发引擎 提供详细的官方文档 支持多种主流的VR硬件设备，具有一定通用性 官网：http://www.worldviz.com/vizard-virtual-reality-software Python库之图形艺术 Quads: 迭代的艺术 对图片进行四分迭代，形成像素风 可以生成动图或静图图像 简单易用，具有很高展示度 官网：https://github.com/fogleman/Quads ascii_art: ASCII艺术库 将普通图片转为ASCII艺术风格 输出可以是纯文本或彩色文本 可采用图片格式输出 官网：https://github.com/jontonsoup4/ascii_art turtle: 海龟绘图体系 龟图形是一种向孩子介绍编程的流行方式。它是Wally Feurzeig，Seymour Papert和Cynthia Solomon在1967年开发的原始徽标编程语言的一部分。 官网：https://docs.python.org/3/library/turtle.html Python库整理 从数据分析到人工智能 数据处理： Numpy、 Pandas、 SciPy 数据可视化： Matplotlib、 Seaborn、 Mayavi 文本：PyPDF2、 NLTK、 python-docx 人工智能：Scikit-learn、 TensorFlow、 MXNet 从Web解析到网络空间 爬虫： Requests、 Scrapy、 pyspider 信息解析：Beautiful Soup、 Re、 Python-Goose 网站开发：Django、 Pyramid、 Flask 网络应用开发： WeRobot、 aip、 MyQR 从人机交互到艺术设计 开发用户界面： PyQt5、 wxPython、 PyGObject 开发游戏： PyGame、 Panda3D、 cocos2d 虚拟现实：VR Zero、 pyovr、 Vizard 艺术设计：Quads、 ascii_art、 turtle","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}]},{"title":"dump - 备份 | restore - 还原","slug":"dump-备份-restore-还原","date":"2020-05-08T03:01:15.000Z","updated":"2020-05-08T03:23:51.887Z","comments":true,"path":"2020/05/08/dump-备份-restore-还原/","link":"","permalink":"http://yoursite.com/2020/05/08/dump-%E5%A4%87%E4%BB%BD-restore-%E8%BF%98%E5%8E%9F/","excerpt":"","text":"dump - 备份 | restore - 还原 确认系统是否有yum云的dump抓包工具，原因dump默认6.3版本没有安装 123[root@localhost ~]# rpm -qa | grep dumpsystem-config-kdump-2.0.5-18.el6.noarchtcpdump-4.0.0-9.20090921gitdf3cb4.2.el6.x86_64 确认好了可以yum安装了 123456[root@localhost ~]# yum -y install dump已加载插件：fastestmirror, refresh-packagekit, security已安装: dump.x86_64 1:0.4-0.6.b42.el6 作为依赖被安装: rmt.x86_64 1:0.4-0.6.b42.el6 安装成功 1234[root@localhost ~]# rpm -qa | grep dumpsystem-config-kdump-2.0.5-18.el6.noarchtcpdump-4.0.0-9.20090921gitdf3cb4.2.el6.x86_64dump-0.4-0.6.b42.el6.x86_64 查看要备份的分区 12345[root@localhost ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/sda2 15G 4.0G 10G 29% /tmpfs 2.0G 72K 2.0G 1% /dev/shm/dev/sda1 190M 39M 142M 22% /boot 进行备份boot分区所有文件并把它保存到/tmp/目录下 123456789101112131415161718192021222324[root@localhost tmp]# dump -0uj -f /tmp/boot.bak.bz2 /boot/ DUMP: Date of this level 0 dump: Fri May 8 10:46:42 2020 DUMP: Dumping /dev/sda1 (/boot) to /tmp/boot.bak.bz2 DUMP: Label: none DUMP: Writing 10 Kilobyte records DUMP: Compressing output at compression level 2 (bzlib) DUMP: mapping (Pass I) [regular files] DUMP: mapping (Pass II) [directories] DUMP: estimated 37808 blocks. DUMP: Volume 1 started with block 1 at: Fri May 8 10:46:42 2020 DUMP: dumping (Pass III) [directories] DUMP: dumping (Pass IV) [regular files] DUMP: Closing /tmp/boot.bak.bz2 DUMP: Volume 1 completed at: Fri May 8 10:46:47 2020 DUMP: Volume 1 took 0:00:05 DUMP: Volume 1 transfer rate: 7071 kB/s DUMP: Volume 1 37920kB uncompressed, 35356kB compressed, 1.073:1 DUMP: 37920 blocks (37.03MB) on 1 volume(s) DUMP: finished in 5 seconds, throughput 7584 kBytes/sec DUMP: Date of this level 0 dump: Fri May 8 10:46:42 2020 DUMP: Date this dump completed: Fri May 8 10:46:47 2020 DUMP: Average transfer rate: 7071 kB/s DUMP: Wrote 37920kB uncompressed, 35356kB compressed, 1.073:1 DUMP: DUMP IS DONE 查看备份成功后的信息 1234[root@localhost tmp]# cd /tmp/[root@localhost tmp]# ll总用量 35360-rw-r--r--. 1 root root 36205112 5月 8 10:46 boot.bak.bz2 备份日志： 12[root@localhost etc]# cat dumpdates/dev/sda1 0 Fri May 8 10:46:42 2020 +0800 拷贝一个文件到boot目下我们做下增量备份 123456[root@localhost boot]# ll -h-rw-------. 1 root root 25M 3月 4 19:05 initramfs-2.6.32-642.el6.x86_64.img [root@localhost boot]# cp initramfs-2.6.32-642.el6.x86_64.img initramfs-2.6.32-642.el6.x86_64.tmp[root@localhost boot]# ll -h -rw-------. 1 root root 25M 3月 4 19:05 initramfs-2.6.32-642.el6.x86_64.img-rw-------. 1 root root 25M 5月 8 10:51 initramfs-2.6.32-642.el6.x86_64.tmp 发现/boot 增加了 64M - 39M = 25M 12345[root@localhost boot]# df -hFilesystem Size Used Avail Use% Mounted on/dev/sda2 15G 4.1G 9.9G 29% /tmpfs 2.0G 72K 2.0G 1% /dev/shm/dev/sda1 190M 64M 117M 36% /boot 第一次增量备份代码 12345678910111213141516171819202122232425[root@localhost boot]# dump -1uj -f /tmp/boot.bak1.bz2 /boot DUMP: Date of this level 1 dump: Fri May 8 10:52:13 2020 DUMP: Date of last level 0 dump: Fri May 8 10:46:42 2020 DUMP: Dumping /dev/sda1 (/boot) to /tmp/boot.bak1.bz2 DUMP: Label: none DUMP: Writing 10 Kilobyte records DUMP: Compressing output at compression level 2 (bzlib) DUMP: mapping (Pass I) [regular files] DUMP: mapping (Pass II) [directories] DUMP: estimated 25073 blocks. DUMP: Volume 1 started with block 1 at: Fri May 8 10:52:13 2020 DUMP: dumping (Pass III) [directories] DUMP: dumping (Pass IV) [regular files] DUMP: Closing /tmp/boot.bak1.bz2 DUMP: Volume 1 completed at: Fri May 8 10:52:16 2020 DUMP: Volume 1 took 0:00:03 DUMP: Volume 1 transfer rate: 8349 kB/s DUMP: Volume 1 25120kB uncompressed, 25049kB compressed, 1.003:1 DUMP: 25120 blocks (24.53MB) on 1 volume(s) DUMP: finished in 3 seconds, throughput 8373 kBytes/sec DUMP: Date of this level 1 dump: Fri May 8 10:52:13 2020 DUMP: Date this dump completed: Fri May 8 10:52:16 2020 DUMP: Average transfer rate: 8349 kB/s DUMP: Wrote 25120kB uncompressed, 25049kB compressed, 1.003:1 DUMP: DUMP IS DONE 查看增量备份的大小很小的速度也很快 1234[root@localhost boot]# ll -h /tmp/总用量 59M-rw-r--r--. 1 root root 25M 5月 8 10:52 boot.bak1.bz2-rw-r--r--. 1 root root 35M 5月 8 10:46 boot.bak.bz2 备份日志： 123[root@localhost boot]# cat /etc/dumpdates/dev/sda1 0 Fri May 8 10:46:42 2020 +0800/dev/sda1 1 Fri May 8 10:52:13 2020 +0800 查看分区的备份等级及记录 1234[root@localhost boot]# dump -WLast dump(s) done (Dump '&gt;' file systems):&gt; /dev/sda2 ( /) Last dump: never /dev/sda1 ( /boot) Last dump: Level 1, Date Fri May 8 10:52:13 2020 还原数据 在/tmp中新建一个目录： 123[root@localhost tmp]# pwd/tmp[root@localhost tmp]# mkdir boot_bak 进行完全备份还原： 12[root@localhost boot_bak]# restore -r -f /tmp/boot.bak.bz2 Dump tape is compressed. 查看： 123456789101112[root@localhost boot_bak]# ll -h总用量 37M-rw-r--r--. 1 root root 106K 5月 11 2016 config-2.6.32-642.el6.x86_64drwxr-xr-x. 3 root root 4.0K 3月 4 19:02 efidrwxr-xr-x. 2 root root 4.0K 3月 4 11:10 grub-rw-------. 1 root root 25M 3月 4 19:05 initramfs-2.6.32-642.el6.x86_64.img-rw-------. 1 root root 5.1M 3月 4 19:08 initrd-2.6.32-642.el6.x86_64kdump.imgdrwx------. 2 root root 4.0K 3月 4 18:55 lost+found-rw-------. 1 root root 93K 5月 8 11:11 restoresymtable-rw-r--r--. 1 root root 211K 5月 11 2016 symvers-2.6.32-642.el6.x86_64.gz-rw-r--r--. 1 root root 2.5M 5月 11 2016 System.map-2.6.32-642.el6.x86_64-rwxr-xr-x. 1 root root 4.1M 5月 11 2016 vmlinuz-2.6.32-642.el6.x86_64 增量还原： 12[root@localhost boot_bak]# restore -r -f /tmp/boot.bak1.bz2 Dump tape is compressed. 发现多了第7行： 12345678910111213[root@localhost boot_bak]# ll -h总用量 61M-rw-r--r--. 1 root root 106K 5月 11 2016 config-2.6.32-642.el6.x86_64drwxr-xr-x. 3 root root 4.0K 3月 4 19:02 efidrwxr-xr-x. 2 root root 4.0K 3月 4 11:10 grub-rw-------. 1 root root 25M 3月 4 19:05 initramfs-2.6.32-642.el6.x86_64.img-rw-------. 1 root root 25M 5月 8 10:51 initramfs-2.6.32-642.el6.x86_64.tmp-rw-------. 1 root root 5.1M 3月 4 19:08 initrd-2.6.32-642.el6.x86_64kdump.imgdrwx------. 2 root root 4.0K 3月 4 18:55 lost+found-rw-------. 1 root root 93K 5月 8 11:13 restoresymtable-rw-r--r--. 1 root root 211K 5月 11 2016 symvers-2.6.32-642.el6.x86_64.gz-rw-r--r--. 1 root root 2.5M 5月 11 2016 System.map-2.6.32-642.el6.x86_64-rwxr-xr-x. 1 root root 4.1M 5月 11 2016 vmlinuz-2.6.32-642.el6.x86_64 注意： 备份文件和目录时，只能使用0级别进行完全备份，而不再支持增量备份","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"dump","slug":"dump","permalink":"http://yoursite.com/tags/dump/"},{"name":"restore","slug":"restore","permalink":"http://yoursite.com/tags/restore/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}]},{"title":"ZooKeeper API 开发","slug":"ZooKeeper-API-开发","date":"2020-05-07T03:03:15.000Z","updated":"2020-05-07T04:09:02.760Z","comments":true,"path":"2020/05/07/ZooKeeper-API-开发/","link":"","permalink":"http://yoursite.com/2020/05/07/ZooKeeper-API-%E5%BC%80%E5%8F%91/","excerpt":"","text":"ZooKeeper API 开发 使用maven开发 ZooKeeper API 配置 pom.xml 文件 123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.zookeeper/zookeeper --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 开发实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186package codes.admin.bigdata.zk;import org.apache.zookeeper.*;import org.apache.zookeeper.data.Stat;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.util.List;import static java.lang.Long.MAX_VALUE;public class ZkClient &#123; private ZooKeeper zkCli; /** * 集群节点 */ private static final String CONNECT_STRING = \"hadoop141:2181,hadoop142:2181,hadoop143:2181\"; /** * 超时时间 */ private static final int SESSION_TIMEOUT = 2000; /** * 实例化zk * * zk监听事件类型，监听自己感兴趣的事件，一旦事件触发，这个时候会回调对应的函数 * 监听器只能用一次，如果需要监听多次，需要重复监听。 * public static enum EventType &#123; * None(-1), * NodeCreated(1), //节点创建事件 * NodeDeleted(2), //节点删除事件 * NodeDataChanged(3), //节点数据变化事件 * NodeChildrenChanged(4); //节点子节点事件变化事件（子节点数量增加和减少） * &#125; *下面三个方法是可以绑定监听器的： * zkCli.getChildren(\"/data\",true); * 感兴趣的事件：NodeChildrenChanged * zkCli.exists(\"/data\",true); * 感兴趣的事件：NodeCreated，NodeDeleted，NodeDataChanged * zkCli.getData(\"/data\",true,null); * 感兴趣的事件：NodeDataChanged * @throws IOException */ @Before public void before() throws IOException &#123; zkCli = new ZooKeeper(CONNECT_STRING, SESSION_TIMEOUT, new Watcher() &#123; //当监听器重复绑定监听的时候 会重复调用 process() 方法 @Override public void process(WatchedEvent watchedEvent) &#123; //获取事件类型 System.out.println(watchedEvent.getType()); //为getChildren绑定监听事件 true表示重复绑定 如果忘了重复绑定监听，监听器只会回调一次 try &#123; zkCli.getChildren(\"/data\",true); //zkCli.exists(\"/data\",true); //zkCli.getData(\"/data\",true,null); &#125; catch (KeeperException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; /** * 获取子节点监听节点变化 * @throws KeeperException * @throws InterruptedException */ @Test public void ls() throws KeeperException, InterruptedException &#123; List&lt;String&gt; children = zkCli.getChildren(\"/\", e-&gt;&#123; System.out.println(\"自定义回调函数！\"); &#125;); System.out.println(\"-------------------------\"); for (String child:children ) &#123; System.out.println(child); &#125; System.out.println(\"-------------------------\"); Thread.sleep(MAX_VALUE); &#125; /** * 创建子节点 * @throws InterruptedException * @throws KeeperException */ @Test public void create() throws InterruptedException, KeeperException &#123; //OPEN_ACL_UNSAFE 能够使所有用户查看 //EPHEMERAL 临时创建 //PERSISTENT 永久创建 // PERSISTENT_SEQUENTIAL 永久创建 自动添加序号 // EPHEMERAL_SEQUENTIAL 临时创建 自动添加序号 String idea = zkCli.create(\"/Idea\", \"Idea2020\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL); //返回路径 System.out.println(idea); Thread.sleep(MAX_VALUE); &#125; /** * 判断Znode是否存在 * @throws KeeperException * @throws InterruptedException */ @Test public void exist() throws KeeperException, InterruptedException &#123; Stat exists = zkCli.exists(\"/Idea0000000006\", false); System.out.println(exists == null ? \"not exist\" : \"exist\" ); &#125; /** * 获取节点数据 * @throws KeeperException * @throws InterruptedException */ @Test public void get() throws KeeperException, InterruptedException &#123; byte[] data = zkCli.getData(\"/1230000000004\", false, new Stat()); String dara = new String(data); System.out.println(dara); &#125; /** * 设置节点数据 * @throws KeeperException * @throws InterruptedException */ @Test public void set() throws KeeperException, InterruptedException &#123; Stat stat = zkCli.setData(\"/234\", \"hello world\".getBytes(), 0); System.out.println(stat.getDataLength()); &#125; /** * 删除节点 * @throws KeeperException * @throws InterruptedException */ @Test public void delete() throws KeeperException, InterruptedException &#123; Stat exists = zkCli.exists(\"/234\", false); if (exists != null)&#123; zkCli.delete(\"/234\",exists.getVersion()); &#125; &#125; /** * @throws KeeperException * @throws InterruptedException */ public void register() throws KeeperException, InterruptedException &#123; byte[] data = zkCli.getData(\"/aa\", new Watcher() &#123; @Override public void process(WatchedEvent watchedEvent) &#123; try &#123; register(); &#125; catch (KeeperException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, null); System.out.println(new String(data)); &#125; @Test public void testRegister() throws KeeperException, InterruptedException &#123; register(); Thread.sleep(MAX_VALUE); &#125;&#125;","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"ZooKeeper","slug":"框架/BigData/ZooKeeper","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/ZooKeeper/"}],"tags":[{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"http://yoursite.com/tags/ZooKeeper/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"ZooKeeper","slug":"框架/BigData/ZooKeeper","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/ZooKeeper/"}]},{"title":"电影-奇幻","slug":"电影-奇幻","date":"2020-05-02T12:53:56.000Z","updated":"2020-05-02T15:16:20.499Z","comments":true,"path":"2020/05/02/电影-奇幻/","link":"","permalink":"http://yoursite.com/2020/05/02/%E7%94%B5%E5%BD%B1-%E5%A5%87%E5%B9%BB/","excerpt":"","text":"&lt;/td&gt; &lt;td&gt; &lt;!--右侧内容--&gt; &lt;b style=&quot;font-size:150%&quot;&gt; 霍比特人1：意外之旅 The Hobbit: An Unexpected Journey (2012) 豆瓣评分 8.1 又名:哈比人：不思议之旅(港),哈比人：意外旅程(台),The Hobbit: Part 1,指环王前传：霍比特人(上) 地区:美国,新西兰 类型:动作,奇幻,冒险 导演:彼得·杰克逊 编剧:弗兰·威尔士菲利帕·鲍恩斯彼得·杰克逊吉尔莫·德尔·托罗J·R·R·托尔金 主演:伊恩·麦克莱恩马丁·弗瑞曼理查德·阿米蒂奇肯·斯托特格拉汉姆·麦克泰维什詹姆斯·内斯比特迪恩·奥戈曼艾丹·特纳雨果·维文凯特·布兰切特安迪·瑟金斯西尔维斯特·迈可伊克里斯托弗·李伊利亚·伍德伊安·霍姆李·佩斯 imdb:tt0903624 中土最后一座矮人王国埃尔波尔，巍峨壮丽，庄严雄伟。老国王索尔积聚大量财富，却引来恶龙史茅革的觊觎和荼毒，最终导致这座城池陷落。许多年后，灰袍巫师甘道夫（伊恩·麦凯伦 Ian McKellen 饰）找到弗罗多的舅舅——霍比特人比尔博·巴金斯（马丁·弗里曼 Martin John C. Freeman 饰），邀请他加入由13名矮人组成的远征队伍。原来史茅革已多年不见声息，背负家国仇恨的矮人王子索林（理查德·阿米蒂奇 Richard Armitage 饰）希望借此机会收复故土。经过一番考虑，巴金斯决定加入。令他想不到的是，远征旅途多灾多难，与索林结下深仇大恨的苍白半兽人及其爪牙阴魂不散，更有食人鬼和石人制造的无数艰险。而在旅途中，巴金斯也意外得到了日后影响整个中土的重要宝物…… 本片根据J.R.R·托尔金的同名原著改编。 资源地址：http://www.pianyuan.la/m_DMb40.html 2.霍比特人2：史矛革之战 The Hobbit: The Desolation of Smaug (2013) 豆瓣评分 8.3 又名:霍比特人2：史矛革荒漠,哈比人：荒谷魔龙(港),哈比人：荒谷恶龙(台),霍比特人2：斯毛戈荒漠,指环王前传：霍比特人(中),The Hobbit: Part 2 地区:美国,新西兰 类型:动作,奇幻,冒险 导演:彼得·杰克逊 编剧:J·R·R·托尔金弗兰·威尔士菲利帕·鲍恩斯彼得·杰克逊吉尔莫·德尔·托罗 主演:伊恩·麦克莱恩马丁·弗瑞曼理查德·阿米蒂奇本尼迪克特·康伯巴奇奥兰多·布鲁姆伊万杰琳·莉莉李·佩斯卢克·伊万斯斯蒂芬·弗雷肯·斯托特詹姆斯·内斯比特约翰·贝尔马努·贝内特杰德·布罗菲亚当·布朗约翰·凯伦瑞安·盖奇马克·哈德洛彼得·汉布尔顿斯蒂芬·亨特威廉·基尔舍西尔维斯特·迈可伊格拉汉姆·麦克泰维什迪恩·奥戈曼米卡埃尔·佩斯布兰特艾丹·特纳 imdb:tt1170358 距离孤山越来越近，矮人远征军的道路却变得异常艰险。他们躲过了苍白半兽人的不懈追杀，在幽暗密林前和甘道夫（伊恩·麦凯伦 Ian McKellen 饰）兵分两路，后者前往多尔哥多探寻索伦的动向，而霍比特人比尔博·巴金斯（马丁·弗里曼 Martin John C. Freeman 饰）和矮人们先是遭到巨大蜘蛛的袭击，随后又被精灵王子莱戈拉斯（奥兰多·布鲁姆 Orlando Bloom 饰）及其木精灵同伴捕获。比尔博急中生智，利用魔戒救出伙伴，继而引发了木精灵、半兽人和矮人远征军之间精彩纷呈的三方会战。借助巴德（卢克·伊万斯 Luke Evans 饰）的帮助，疲惫的矮人们暂时落脚长湖镇。近在咫尺的孤山城堡，沉睡在财宝中的巨龙即将醒来…… 本片根据J.R.R·托尔金的同名原著改编。 资源地址：http://www.pianyuan.la/m_DmtxWLbc0.html 3. 霍比特人3：五军之战 The Hobbit: The Battle of the Five Armies (2014) 豆瓣评分 8.2 又名:哈比人：五军之战(港台),哈比人：奇境再返(台),哈比人：汗血回归,指环王前传：霍比特人(下),霍比特人3：去而复返,There and Back Again 地区:美国,新西兰 类型:动作,奇幻,冒险 导演:彼得·杰克逊 编剧:弗兰·威尔士菲利帕·鲍恩斯彼得·杰克逊吉尔莫·德尔·托罗J·R·R·托尔金 主演:马丁·弗瑞曼伊恩·麦克莱恩理查德·阿米蒂奇伊万杰琳·莉莉李·佩斯卢克·伊万斯本尼迪克特·康伯巴奇肯·斯托特詹姆斯·内斯比特比利·康诺利凯特·布兰切特伊安·霍姆克里斯托弗·李雨果·维文奥兰多·布鲁姆马努·贝内特艾丹·特纳迪恩·奥戈曼格拉汉姆·麦克泰维什斯蒂芬·弗雷米卡埃尔·佩斯布兰特 imdb:tt2310332 最先与灭霸军团遭遇的雷神索尔一行遭遇惨烈打击，洛基遇害，空间宝石落入灭霸之手。未几，灭霸的先锋部队杀至地球，一番缠斗后掳走奇异博士。为阻止时间宝石落入敌手，斯塔克和蜘蛛侠闯入了敌人的飞船。与此同时，拥有心灵宝石的幻视也遭到外星侵略者的袭击，为此美国队长、黑寡妇等人将其带到瓦坎达王国，向黑豹求助。幸免于难的索尔与星爵一行相逢，随后他们兵分两路。索尔与火箭、格鲁特踏上再铸雷神之锤的旅程，星爵则与卡魔拉等人试图阻止灭霸的恶行。而知晓灵魂宝石下落的卡魔拉，同样是其义父灭霸追踪的对象。 攸关整个宇宙命运的史诗战役全面展开，超级英雄们为了平凡而自由的生命奋不顾身…… 资源地址：http://www.pianyuan.la/m_DwbXEHuc0.html 4. 指环王1：魔戒再现 The Lord of the Rings: The Fellowship of the Ring (2001) 豆瓣评分 8.9 又名:魔戒首部曲：魔戒现身,指环王I：护戒使者,魔戒1：护戒联盟 地区:新西兰,美国 类型:剧情,动作,奇幻,冒险 导演:彼得·杰克逊 编剧:弗兰·威尔士菲利帕·鲍恩斯彼得·杰克逊J·R·R·托尔金 主演:伊利亚·伍德西恩·奥斯汀伊恩·麦克莱恩维果·莫腾森奥兰多·布鲁姆凯特·布兰切特肖恩·宾克里斯托弗·李雨果·维文丽芙·泰勒安迪·瑟金斯伊安·霍姆多米尼克·莫纳汉萨拉·贝克约翰·瑞斯-戴维斯 imdb:tt01207374 比尔博•巴金斯是100多岁的哈比人，住在故乡夏尔，生性喜欢冒险，在年轻时的一次探险经历中，他从怪物咕噜手中得到了至尊魔戒，这枚戒指是黑暗魔君索伦打造的至尊魔戒，拥有奴役世界的邪恶力量，能够统领其他几枚力量之戒，在3000年前的人类联盟和半兽人大军的战役中，联盟取得了胜利 ，并得到了至尊魔戒，数千年的辗转后，魔戒落到咕噜手中，被比尔博碰巧得到。 因为和魔戒的朝夕相处，比尔博的心性也受到了影响，在他111岁的生日宴会上，他决定把一切都留给侄子佛罗多(伊莱贾‧伍德 饰)，继续冒险。 比尔博的好朋友灰袍巫师甘道夫（伊恩‧麦凯伦 饰）知道至尊魔戒的秘密，同时，黑暗魔君索伦已经知道他的魔戒落在哈比族的手中。索伦正在重新建造要塞巴拉多，集结无数的半兽人，准备以大军 夺取魔戒，并且征服全世界。 甘道夫说服佛罗多将魔戒护送到精灵王国瑞文希尔，佛罗多在好朋友山姆、皮平和梅利的陪同下，在跃马旅店得到了刚铎王子阿拉贡的帮助，历经艰难，终于到达了精灵王国。 然而，精灵族并不愿意保管这个邪恶的至尊魔戒，中土各国代表开会讨论，达成意见，准备将至尊魔戒送到末日山脉的烈焰中彻底销毁，佛罗多挺身而出接受了这个任务，这次，陪伴他的除了三个好朋友，还有甘道夫、阿拉贡、精灵莱戈拉斯（奥兰多‧布鲁姆 饰）、人类博罗米尔、侏儒金利。 一路上，魔戒远征军除了要逃避索伦爪牙黑骑士和半兽人的追杀之外，更要抵抗至尊魔戒本身的邪恶诱惑，前途困难重重。 资源地址：http://www.pianyuan.la/m_Dt5b0.html 5.指环王2：双塔奇兵 The Lord of the Rings: The Two Towers (2002) 豆瓣评分 8.9 又名:魔戒二部曲：双城奇谋,指环王II：双塔,魔戒2：双塔奇谋 地区:美国,新西兰 类型:剧情,动作,奇幻,冒险 导演:彼得·杰克逊 编剧:弗兰·威尔士菲利帕·鲍恩斯Stephen Sinclair彼得·杰克逊J·R·R·托尔金 主演:伊利亚·伍德西恩·奥斯汀伊恩·麦克莱恩维果·莫腾森奥兰多·布鲁姆克里斯托弗·李丽芙·泰勒安迪·瑟金斯雨果·维文卡尔·厄本凯特·布兰切特多米尼克·莫纳汉大卫·文翰比利·博伊德布拉德·道里夫伯纳德·希尔约翰·瑞斯-戴维斯米兰达·奥图 imdb:tt0167261 第二部在延续第一部风格的同时，故事呈现出多线发展的格局，情节有了更高的观赏性。 第一部结尾，博罗米尔被强兽人杀死之后，两个哈比族人皮平和梅利也被强兽人绑架，阿拉贡、精灵莱戈拉斯（奥兰多•布鲁姆 饰）、侏儒金利一路追踪强兽人，营救皮平和梅利，遇到了“复活”的白袍巫师甘道夫（伊恩•麦凯伦 饰）。此时，投降索伦的白袍巫师萨鲁曼控制了人类洛汉王国的国王，并派出大量的强兽人军队，准备消灭人类。阿拉贡、莱戈拉斯和金利在甘道夫的带领下，帮助洛汉王国对抗邪恶力量的入侵。 幸运的皮平和梅利被会说话的树精救了出来，并且遇到“复活”的甘道夫，在甘道夫的授意下，树精保护了两人的安全，并且带他们参加树精大会，大会上，树精们讨论对待中土大战的态度：是继续当中立者，逆来顺受，还是奋起反抗？ 身负重任的佛罗多(伊莱贾•伍德 饰)和山姆继续向末日山脉前进，一路上被咕噜跟踪，弗罗多依靠至尊魔戒的力量，成为了咕噜的主人，在咕噜的带领下，他们到了末日山脉的入口，黑门。就在他们准备进入之时，博罗米尔的弟弟法莫尔出现，将他们带回了刚铎。弗罗多又遇上了新的危机：法莫尔想利用至尊魔戒的力量对抗萨鲁曼的攻击…… 资源地址：http://www.pianyuan.la/m_Dt430.html &lt;/td&gt; &lt;td&gt; &lt;!--右侧内容--&gt; &lt;b style=&quot;font-size:150%&quot;&gt; 指环王3：王者无敌 The Lord of the Rings: The Return of the King (2003) 豆瓣评分 9.1 又名:魔戒三部曲：王者再临,指环王III：王者无敌,魔戒3：王者归来,指环王3：国王归来 地区:美国,新西兰 类型:剧情,动作,奇幻,冒险 导演:彼得·杰克逊 编剧:弗兰·威尔士菲利帕·鲍恩斯彼得·杰克逊J·R·R·托尔金 主演:维果·莫腾森伊利亚·伍德西恩·奥斯汀丽芙·泰勒伊恩·麦克莱恩奥兰多·布鲁姆凯特·布兰切特米兰达·奥图安迪·瑟金斯雨果·维文多米尼克·莫纳汉比利·博伊德马尔顿·索克斯卡尔·厄本克里斯托弗·李约翰·瑞斯-戴维斯 imdb:tt0167260 魔幻战争逐渐进入高潮阶段。霍比特人弗拉多（伊利亚·伍德 Elijah Wood 饰）携带着魔戒，与伙伴山姆（Sean Astin 饰）以及狡猾阴暗的咕噜等前往末日山，一路上艰难险阻不断，魔君索伦为阻止魔戒被销毁用尽全力阻挠。另一方面，白袍巫师甘道夫（伊安·麦克莱恩 Ian McKellen 饰）率中土勇士们镇守刚铎首都——白城米那斯提里斯。魔兽大军压境，黑暗与光明的决战即将来临…… 本片是“指环王三部曲”的终结篇，根据英国作家J.R.R.托尔金（J.R.R. Tolkien）同名魔幻巨著《指环王》（The Lord of the Rings）改编，并荣获2004年第76届奥斯卡最佳影片、最佳导演、最佳改编剧本、最佳剪辑、最佳艺术指导、最佳服装设计、最佳化妆、最佳视觉效果、最佳音效、最佳配乐和最佳歌曲等11项大奖。 资源地址：http://www.pianyuan.la/m_Dt4z0.html &lt;/td&gt; &lt;td&gt; &lt;!--右侧内容--&gt; &lt;b style=&quot;font-size:150%&quot;&gt; 波西·杰克逊与神火之盗 Percy Jackson &amp; the Olympians: The Lightning Thief (2010) (2003) 豆瓣评分 5.9 又名:珀西·杰克逊和闪电窃贼,波西杰克森：神火之贼,波西·杰克逊与闪电贼,Percy Jackson and the Lightning Thief 地区:美国,加拿大 类型:奇幻,冒险 导演:克里斯·哥伦布 编剧:Craig TitleyRick Riordan 主演:罗根·勒曼布兰登·T·杰克逊亚历珊德拉·达达里奥凯瑟琳·基纳皮尔斯·布鲁斯南乌玛·瑟曼杰克·阿贝尔肖恩·宾罗莎里奥·道森凯文·麦克基德 imdb:tt0814255 黑夜，天神宙斯召见海神波塞冬，称其子偷了闪电火，要挟他若不尽快找回，必将开战。现实中，波塞冬与人妻萨利之子波西杰克逊（罗根•勒曼 Logan Lerman 饰）是个大学生，17岁的他可以在水下呆7分钟，但对老师关于莎翁的提问不感兴趣。参观博物馆时，他遇到了摇着轮椅的人马老师（皮尔斯•布鲁斯南 Pierce Brosnan 饰）。而文学老师却变身成了复仇女神，向他逼问闪电火的下落。幸好人马教授和羊男朋友及时赶到，化险为夷。他们带波西来到营地，训练波西，他们找来了一个女战士安娜贝斯（亚历山德拉•达达里奥 Alexandra Daddario饰）与之比武。落败后，触水的波西被激活了潜能，成为奋勇无敌的战士，并开始踏上了追寻闪电火的英雄之旅。面对蛇女美杜莎等神怪的攻击，冥王冥后珀尔赛弗涅的刁难，他的自我救赎只剩下10天…… 资源地址：http://www.pianyuan.la/m_Dt4NWFcc0.html 8. 波西·杰克逊与魔兽之海 Percy Jackson: Sea of Monsters (2013) 豆瓣评分 5.5 又名:波西杰克森：妖魔之海(港/台),波西杰克逊2,波西·杰克逊与海怪,Percy Jackson & the Olympians: The Sea of Monsters 地区:美国 类型:剧情,动作,奇幻,冒险 导演:托尔·弗洛伊德桑尔 编剧:马克·古根海姆里克·赖尔登 主演:罗根·勒曼亚历珊德拉·达达里奥布兰登·T·杰克逊道格拉斯·史密斯莱文·兰宾杰克·阿贝尔安东尼·海德斯坦利·图齐 imdb:tt1854564 电影《波西·杰克逊与魔兽之海》由《小屁孩日记》导演托尔·弗洛伊德桑尔执导，讲述波西·杰克逊在混血人集中营平静的度过七年级后，忽然日子就变的纷乱了起来，原本和同学间的躲避球竞赛，阴错阳差的变成了一场死亡游戏，丑陋的食人族巨无霸也跟着搅和其中，波西无意中发现，他们的家园和族人正遭遇空前的灾难，必须找到“金羊毛”，才能拯救众人，为了解除灾难，波西奋不顾身带着伙伴们共同踏上冒险的旅程，他们要到魔兽之海完成任务，才能取得金羊毛并拯救面临毁灭的混血人集中营，在这趟危机重重的冒险之旅中，他们将会遇到哪些惊人的意外难关?他们真的能够顺利的突破困难，并且让所有族人和希腊众神们幸免于难吗? 资源地址：http://www.pianyuan.la/m_Sm5XWzcc0.html &lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; 哈利·波特与魔法石 Harry Potter and the Sorcerer's Stone (2001) 豆瓣评分 8.5 又名:哈利波特1：神秘的魔法石(港/台),哈1,Harry Potter and the Philosopher's Stone 地区:美国,英国 类型:奇幻,冒险 导演:克里斯·哥伦布 编剧:斯蒂芬·科洛弗J·K·罗琳 主演:丹尼尔·雷德克里夫艾玛·沃森鲁伯特·格林特艾伦·瑞克曼玛吉·史密斯汤姆·费尔顿伊恩·哈特理查德·哈里斯约翰·赫特罗彼·考特拉尼朱丽·沃特斯邦妮·怀特约翰·克立斯肖恩·比格斯代夫 imdb:tt0241527 哈利波特是一个孤儿，从小寄养在姨妈家，受尽欺凌。但就在哈利11岁生日的时候，他意外收到了霍格沃茨学院的入学通知书。哈利从该学院派来接他的巨人海格口中得知，这是一间魔法学院，并得知了自己的身世，原来哈利的父母都是伟大的魔法师，在对付伏地魔的战斗中双双献身，唯有哈利幸免于难。 哈利进入霍格沃茨后，表现出了超乎想象的飞行天赋，得到麦格教授的推荐进入了格兰芬多的魁地奇球队。另一方面，哈利发现霍格沃茨学院内有一股黑暗势力似乎在暗暗滋长，揭开谜团的关键就在有凶恶的三头犬守护的房间内。 哈利、罗恩和赫敏三个好朋友决定探个究竟。 资源地址：http://www.pianyuan.la/m_DwbzEQcc0.html 哈利·波特与密室 Harry Potter and the Chamber of Secrets (2002) 豆瓣评分 8.0 又名:哈利波特2：消失的密室(港/台),哈2 地区:美国,英国,德国 类型:奇幻,冒险 导演:克里斯·哥伦布 编剧:斯蒂芬·科洛弗J·K·罗琳 主演:丹尼尔·雷德克里夫艾玛·沃森鲁伯特·格林特汤姆·费尔顿理查德·格雷弗斯费奥纳·肖托比·琼斯朱丽·沃特斯邦妮·怀特詹森·艾萨克肯尼思·布拉纳艾伦·瑞克曼理查德·哈里斯玛吉·史密斯约翰·克立斯肖恩·比格斯代夫克里斯·兰金克里斯蒂安·库尔森 imdb:tt02952970 哈利波特（丹尼尔•雷德克里夫 Daniel Radcliffe 饰）结束了假期，即将回到霍格沃兹继续学习魔法。一个叫多比的家养小精灵警告哈利不要回到霍格沃兹，否则会陷入极大的危险。哈利没有听从多比的劝告，回到了霍格沃兹。很快，霍格沃兹发生了一连窜怪事:接二连三出现学生被石化，一直找不出原因。而哈利总能听到一种奇怪的声音，从墙壁里传出来。 传说，霍格沃兹有一个密室，里面记录着伏地魔年轻时的秘密，只有斯莱特林的人才能打开密室。哈利偶然发现自己能听懂蛇说话，一时传闻是哈利打开了密室。难道多比所指的危险就隐藏在密室？ 资源地址：http://www.pianyuan.la/m_68bXEpcc0.html 哈利·波特与阿兹卡班的囚徒 Harry Potter and the Prisoner of Azkaban (2004) 豆瓣评分 8.0 又名:哈利波特3：阿兹卡班的逃犯(港/台),哈利·波特与阿兹卡班的逃犯,哈3 地区:英国,美国 类型:剧情,奇幻,冒险 导演:阿方索·卡隆 编剧:斯蒂芬·科洛弗J·K·罗琳 主演:丹尼尔·雷德克里夫艾玛·沃森鲁伯特·格林特加里·奥德曼朱丽·沃特斯邦妮·怀特大卫·休里斯迈克尔·刚本艾伦·瑞克曼玛吉·史密斯汤姆·费尔顿艾玛·汤普森朱莉·克里斯蒂蒂莫西·斯波 imdb:tt0304141 哈利（丹尼尔·雷德克里夫）即将在霍格沃兹渡过第三个年头，此时在阿兹塔班却传出恶棍小天狼星（加里·奥德曼）越狱的消息。据说小天狼星正是背叛哈利父母的好友，他的教父，而这次小天狼星越狱似乎正是为了找他。哈利的心里悄悄的滋生了为父母报仇的想法，期待着小天狼星的出现。 新来的魔法老师卢平（大卫·休里斯）有着桀骜不驯的个性，与哈利关系很好，教了哈利许多实用的黑魔法防御知识。而此时在他的魔法地图上却出现了一个神秘人物，虫尾巴。偶然的机会下，在尖叫棚屋里集齐了哈利父亲当年的所有好友，卢平、虫尾巴、小天狼星，哈利的魔杖直指向小天狼星，但他发现那罪犯看他的眼神里充满了疼爱…… 资源地址：http://www.pianyuan.la/m_Dm5fELcc0.html 哈利·波特与火焰杯 Harry Potter and the Goblet of Fire (2005) 豆瓣评分 7.9 > 又名:哈利波特4：火杯的考验(港/台),哈4 地区:英国,美国 类型:奇幻,冒险 导演:迈克·内威尔 编剧:斯蒂芬·科洛弗J·K·罗琳 主演:丹尼尔·雷德克里夫艾玛·沃森鲁伯特·格林特蒂莫西·斯波邦妮·怀特罗伯特·帕丁森汤姆·费尔顿梁佩诗迈克尔·刚本玛吉·史密斯艾伦·瑞克曼加里·奥德曼拉尔夫·费因斯 imdb:tt0330373 这是一个不同寻常的学期，魔法学校的盛事：三强争霸赛在霍格沃茨举行。学生们争先报名，希翼获得永恒无上的荣誉。火焰杯在选出三所学校的三名勇士后，竟将未足年龄的哈利也挑选出来。 哈利（Daniel Radcliffe饰）的当选引起其他学生的嫉妒连连，就连铁哥们罗恩（Rupert Grint饰）也首次和他闹起了别扭，哈利感到孤立无援，还好有教父小天狼星和赫敏一直支持他。可总有些好事者如记者丽塔等着看他的好戏。天知道这场比赛是何等艰辛危险，在龙的眼皮下偷蛋，潜入湖底救人，在迷宫中探险……一不小心，甚至可能付出生命的代价。 黑魔王伏地魔的威胁渐渐显现，每一天都险象环生，动人心弦。 资源地址：http://www.pianyuan.la/m_Dwtdcpcc0.html 哈利·波特与凤凰社 Harry Potter and the Order of the Phoenix (2007) 豆瓣评分 7.6 又名:哈利波特5：凤凰会的密令(港/台),哈5 地区:英国,美国 类型:奇幻,冒险 导演:大卫·叶茨 编剧:迈克尔·戈登伯格J·K·罗琳 主演:丹尼尔·雷德克里夫艾玛·沃森鲁伯特·格林特加里·奥德曼拉尔夫·费因斯玛吉·史密斯迈克尔·刚本艾伦·瑞克曼艾玛·汤普森艾美达·斯丹顿詹森·艾萨克汤姆·费尔顿海伦娜·伯翰·卡特邦妮·怀特朱丽·沃特斯梁佩诗布莱丹·格里森罗彼·考特拉尼伊文娜·林奇 imdb:tt0373889 逃过摄魂怪的追杀，通过魔法部的审查，哈利（丹尼尔·雷德克里夫）终于回到美丽的霍格沃兹。然而这个学期并不轻松，他不仅要完成魔法等级考试，还要应对夜晚的噩梦和黑魔法防御课老师乌姆里奇的打压。在好友的支持下，哈利秘密组建了邓不利多军团，与大家一起练习黑魔法防御术。 噩梦中，哈利总是以伏地魔的视角出现，似乎他们之间有着某种神秘的联系。在邓不利多（迈克尔·刚本）的指示下，哈利向斯内普教授（阿伦·瑞克曼）学习封闭术，却鲜有成效。终于在一次噩梦的诱使下，哈利偏执的赶往魔法部营救小天狼星，却不想陷入伏地魔的圈套，引发凤凰社与食死徒之间的正面冲突。在混战中，小天狼星（加里·奥德曼）不幸遇难。 究竟哈利与伏地魔（拉尔夫·费因斯）之间有着怎样的联系？在悲恸中，邓不利多为哈利揭开谜底，哈利还有更长、更艰难的路要走…… 资源地址：http://www.pianyuan.la/m_Sm83WQcc0.html 哈利·波特与混血王子 Harry Potter and the Half-Blood Prince (2009) 豆瓣评分 7.2 又名:哈利波特6：混血王子的背叛(港/台),哈6,HP and the HBP 地区:英国,美国 类型:剧情,奇幻,冒险 导演:大卫·叶茨 编剧:斯蒂芬·科洛弗J·K·罗琳 主演:丹尼尔·雷德克里夫艾玛·沃森鲁伯特·格林特汤姆·费尔顿迈克尔·刚本艾伦·瑞克曼邦妮·怀特朱丽·沃特斯海伦娜·伯翰·卡特吉姆·布劳德本特玛吉·史密斯伊文娜·林奇 imdb:tt0417741 这一集中，食死徒开始肆无忌惮横行于麻瓜和魔法两个世界中，霍格沃茨内忧外患，危机重重。邓不利多（迈克尔·甘本 Michael Gambon 饰）带着哈利（丹尼尔·雷德克里夫 Daniel Radcliffe 饰）辗转找到隐居多年的霍拉斯·斯拉格霍恩，请他出山接替斯内普（艾伦 ·里克曼 Alan Rickman 饰）担任魔药学的老师。霍拉斯曾经教授过无数优秀的学生，而汤姆·里德尔——伏地魔——正是他最出色的一名弟子。邓不利多深信霍拉斯保有伏地魔不死身的秘密，他希望哈利能够说服霍拉斯。 另一方面，德拉科·马尔福（汤姆·费尔顿 Tom Felton 饰）宣誓效忠伏地魔，他想方设法将食死徒引入霍格沃茨。而此时，罗恩（鲁伯特·格林特 Rupert Grint 饰）、赫敏（艾玛·沃特森 Emma Watson 饰）他们却还沉浸在青春的躁动中，全然不知黑暗正渐渐逼近…… 资源地址：http://www.pianyuan.la/m_Sm5X0.html 哈利·波特与死亡圣器(上) Harry Potter and the Deathly Hallows: Part 1 (2010) 豆瓣评分 7.7 又名:哈利波特7：死神的圣物1(港/台),哈利·波特与死圣(上),哈7(上) 地区:英国,美国 类型:剧情,奇幻,冒险 导演:大卫·叶茨 编剧:斯蒂芬·科洛弗 主演:丹尼尔·雷德克里夫艾玛·沃森鲁伯特·格林特海伦娜·伯翰·卡特拉尔夫·费因斯比尔·奈伊约翰·赫特艾伦·瑞克曼艾美达·斯丹顿费奥纳·肖邦妮·怀特朱丽·沃特斯米歇尔·费尔利杰米·坎贝尔·鲍尔 imdb:tt0926084 《哈利·波特与死亡圣器》小站 http://site.douban.com/108361/ 邓不利多死后，伏地魔（Ralph Fiennes 饰）与食死徒入侵魔法学校，魔法部也被伏地魔的爪牙操控，邪恶的阴云笼罩魔法世界上空。在哈利·波特（丹尼尔·雷德克里夫 Daniel Radcliffe 饰）17岁生日之际，凤凰社成员及一众好友护送他回到了凤凰社的据点陋居，然而这立即遭到食死徒毁灭性地打击。哈利和罗恩（鲁伯特·格林特 Rupert Grint 饰）、赫敏（爱玛·沃特森 Emma Watson 饰）侥幸逃亡，并且按照邓不利多的嘱托继续寻找伏地魔的魂器。死亡的威胁时刻逡巡左右，他们还要面对友情的考验。在寻找摧毁魂器方法的过程中，死亡圣器的面纱也渐渐揭开。 与此同时，为了置哈利于死地，伏地魔也在寻找最后一件死亡圣器。最后的决战即将到来…… 资源地址：http://www.pianyuan.la/m_S883Wzcc0.html 哈利·波特与死亡圣器(下) Harry Potter and the Deathly Hallows: Part 2 (2011) 豆瓣评分 8.6 又名:哈利波特7：死神的圣物2(港/台),哈利·波特与死圣(下),哈7(下),哈利·波特大结局 地区:美国,英国 类型:剧情,悬疑,奇幻,冒险 导演:大卫·叶茨 编剧:斯蒂芬·科洛弗 主演:丹尼尔·雷德克里夫艾玛·沃森鲁伯特·格林特海伦娜·伯翰·卡特拉尔夫·费因斯艾伦·瑞克曼玛吉·史密斯汤姆·费尔顿邦妮·怀特朱丽·沃特斯迈克尔·刚本伊文娜·林奇多姆纳尔·格利森克蕾曼丝·波西詹森·艾萨克海伦·麦克洛瑞马修·刘易斯梁佩诗 imdb:tt1201607 当又一次和伏地魔（拉尔夫·费因斯 Ralph Fiennes 饰）的意识连通，哈利·波特（丹尼尔·雷德克里夫 Daniel Radcliffe 饰）断定最后一件魂器藏在霍格沃茨，于是和罗恩（鲁伯特·格林特 Rupert Grint 饰）、赫敏（艾玛·沃森 Emma Watson 饰）一同返回阴云密布的学校。在好友们的帮助下，他们成功驱逐了斯内普（艾伦·瑞克曼 Alan Rickman 饰），然而觉察到哈利目的的伏地魔则率领徒众向霍格沃茨逼近。食死徒、摄魂怪、巨人疯狂涌入这所有着悠久历史的魔法学校，正邪决战旋即爆发，一时间血雨腥风，死伤无数。从斯内普的眼泪中，哈利不仅了解到父辈的故事，也证实了藏缅于他体内最后的秘密。在此之后，他也和伏地魔迎来了最后的对决…… 本片根据英国作家J.K.罗琳的同名原著改编，也是“哈利·波特”系列影片的完结篇。 资源地址：http://www.pianyuan.la/m_Dwb3czcc0.html ----","categories":[{"name":"电影","slug":"电影","permalink":"http://yoursite.com/categories/%E7%94%B5%E5%BD%B1/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://yoursite.com/tags/%E7%94%B5%E5%BD%B1/"},{"name":"奇幻","slug":"奇幻","permalink":"http://yoursite.com/tags/%E5%A5%87%E5%B9%BB/"}],"keywords":[{"name":"电影","slug":"电影","permalink":"http://yoursite.com/categories/%E7%94%B5%E5%BD%B1/"}]},{"title":"电影-科幻","slug":"电影-科幻","date":"2020-05-02T12:51:46.000Z","updated":"2020-05-02T12:54:03.242Z","comments":true,"path":"2020/05/02/电影-科幻/","link":"","permalink":"http://yoursite.com/2020/05/02/%E7%94%B5%E5%BD%B1-%E7%A7%91%E5%B9%BB/","excerpt":"","text":"1. 复仇者联盟 The Avengers (2012) 豆瓣评分 8.0 地区:美国 类型:动作,科幻,奇幻,冒险 导演:乔斯·韦登 编剧:乔斯·韦登扎克·佩恩 主演:小罗伯特·唐尼克里斯·埃文斯斯嘉丽·约翰逊克里斯·海姆斯沃斯杰瑞米·雷纳马克·鲁弗洛塞缪尔·杰克逊汤姆·希德勒斯顿斯特兰·斯卡斯加德寇碧·史莫德斯克拉克·格雷格保罗·贝坦尼格温妮斯·帕特洛 imdb:tt0848228 一股突如其来的强大邪恶势力对地球造成致命威胁，没有任何一个超级英雄能够单独抵挡。长期致力于保护全球安危的神盾局（SHIELD）感到措手不及，其指挥官“独眼侠”尼克·弗瑞（塞缪尔·杰克逊 Samuel L. Jackson 饰）意识到他必须创建一个“史上最强”的联盟组织， 云集各方超级英雄一起发威，才能拯救世界于水深火热，抵御黑暗势力的侵袭。于是由六大超级英雄——“钢铁侠”（小罗伯特·唐尼 Robert Downey Jr. 饰）、“雷神” （克里斯·海姆斯沃斯 Chris Hemsworth 饰）、“美国队长”（克里斯·埃文斯 Chris Evans 饰）、“绿巨人” （马克·鲁弗洛 Mark Ruffalo 饰）、“黑寡妇”（斯嘉丽·约翰逊 Scarlett Johansson 饰）和“鹰眼”（杰瑞米·雷纳 Jeremy Renner 饰）组成的 “复仇者联盟”应运而生。他们各显神通，团结一心，终于战胜了邪恶势力，保证了地球的安全。 资源地址：http://www.pianyuan.la/m_Dm5bWQcc0.html 2. 复仇者联盟2：奥创纪元 Avengers: Age of Ultron (2015) 豆瓣评分 7.1 地区:美国 类型:动作,科幻,奇幻,冒险 导演:乔斯·韦登 编剧:乔斯·韦登斯坦·李杰克·科比 主演:小罗伯特·唐尼克里斯·海姆斯沃斯马克·鲁弗洛克里斯·埃文斯斯嘉丽·约翰逊杰瑞米·雷纳詹姆斯·斯派德塞缪尔·杰克逊唐·钱德尔亚伦·泰勒-约翰逊伊丽莎白·奥尔森保罗·贝坦尼寇碧·史莫德斯安东尼·麦凯海莉·阿特维尔伊德里斯·艾尔巴斯特兰·斯卡斯加德金秀贤托马斯·克莱舒曼安迪·瑟金斯朱莉·德尔佩斯坦·李亨利·古德曼多米尼克·普罗沃斯特-切克利艾萨克·安德鲁斯 imdb:tt2395427 一股突如其来的强大邪恶势力对地球造成致命威胁，没有任何一个超级英雄能够单独抵挡。长期致力于保护全球安危的神盾局（SHIELD）感到措手不及，其指挥官“独眼侠”尼克·弗瑞（塞缪尔·杰克逊 Samuel L. Jackson 饰）意识到他必须创建一个“史上最强”的联盟组织， 云集各方超级英雄一起发威，才能拯救世界于水深火热，抵御黑暗势力的侵袭。于是由六大超级英雄——“钢铁侠”（小罗伯特·唐尼 Robert Downey Jr. 饰）、“雷神” （克里斯·海姆斯沃斯 Chris Hemsworth 饰）、“美国队长”（克里斯·埃文斯 Chris Evans 饰）、“绿巨人” （马克·鲁弗洛 Mark Ruffalo 饰）、“黑寡妇”（斯嘉丽·约翰逊 Scarlett Johansson 饰）和“鹰眼”（杰瑞米·雷纳 Jeremy Renner 饰）组成的 “复仇者联盟”应运而生。他们各显神通，团结一心，终于战胜了邪恶势力，保证了地球的安全。 资源地址：http://www.pianyuan.la/m_Dw4Xcfcc0.html 3. 复仇者联盟3：无限战争 Avengers: Infinity War (2018)豆瓣评分 8.5 地区:美国 类型:动作,科幻,奇幻,冒险 导演:安东尼·罗素乔·罗素 编剧:杰克·科比克里斯托弗·马库斯斯蒂芬·麦克菲利吉姆·斯特林 主演:小罗伯特·唐尼克里斯·海姆斯沃斯克里斯·埃文斯马克·鲁弗洛乔什·布洛林斯嘉丽·约翰逊汤姆·赫兰德伊丽莎白·奥尔森保罗·贝坦尼汤姆·希德勒斯顿克里斯·普拉特佐伊·索尔达娜本尼迪克特·康伯巴奇查德维克·博斯曼塞巴斯蒂安·斯坦唐·钱德尔本尼迪克特·王安东尼·麦凯戴夫·巴蒂斯塔布莱德利·库珀范·迪塞尔凯伦·吉兰利蒂希娅·赖特庞·克莱门捷夫凯莉·库恩汤姆-沃 imdb:tt4154756 最先与灭霸军团遭遇的雷神索尔一行遭遇惨烈打击，洛基遇害，空间宝石落入灭霸之手。未几，灭霸的先锋部队杀至地球，一番缠斗后掳走奇异博士。为阻止时间宝石落入敌手，斯塔克和蜘蛛侠闯入了敌人的飞船。与此同时，拥有心灵宝石的幻视也遭到外星侵略者的袭击，为此美国队长、黑寡妇等人将其带到瓦坎达王国，向黑豹求助。幸免于难的索尔与星爵一行相逢，随后他们兵分两路。索尔与火箭、格鲁特踏上再铸雷神之锤的旅程，星爵则与卡魔拉等人试图阻止灭霸的恶行。而知晓灵魂宝石下落的卡魔拉，同样是其义父灭霸追踪的对象。 攸关整个宇宙命运的史诗战役全面展开，超级英雄们为了平凡而自由的生命奋不顾身…… 资源地址：http://www.pianyuan.la/m_DtwfWcuc0.html 钢铁侠 Iron Man (2008) 豆瓣评分 7.7 地区:美国 类型:动作,科幻,惊悚,冒险 导演:乔恩·费儒 编剧:特·马库姆马特·霍洛维马克·弗格斯霍克·奥斯比 主演:小罗伯特·唐尼泰伦斯·霍华德格温妮斯·帕特洛杰夫·布里吉斯莱丝莉·比伯肖恩·托布保罗·贝坦尼乔恩·费儒克拉克·格雷格 imdb:tt0371746 斯塔克军火公司是美军在全球范围内第一大军火供应商，其新任掌门人托尼•斯塔克（小罗伯特·唐尼 Robert Downey Jr. 饰）风流倜傥，天资聪颖。他与公司元老俄巴迪亚•斯坦（杰夫·布里吉斯 Jeff Bridges 饰）合作无间，共同将斯塔克公司的业务推向顶峰。现 实生活中的托尼热衷收集名贵跑车，搞点儿发明创造，当然露水姻缘更不可少。所幸他身边有维吉尼亚•波茨（格温妮斯·帕特洛 Gwyneth Paltrow 饰）这样的好助手细心打理一切，才让他能自由自在过着贵公子的生活。 在前往中东为军方展示新型武器的途中，托尼一众遭到恐怖分子袭击。他被弹片击中险些丧命，在英森博士的帮助下，托尼体内移植了一颗核动力的人工心脏。恐怖分子要求托尼制造强大的杀伤性武器，他和英森虚与委蛇，暗中制造了一套由聚变能源驱动的钢铁盔甲。穿上盔甲托尼大闹恐怖分子的基地，回到美国后又对其进行了改进。却不知，接下来有更为黑暗的阴谋等着他…… 资源地址：http://www.pianyuan.la/m_DwwfWpcc0.html 钢铁侠2 Iron Man 2 (2010) 豆瓣评分 7.0 地区:美国 类型:动作,科幻,冒险 导演:乔恩·费儒 编剧:贾斯汀·塞洛克斯 主演:小罗伯特·唐尼格温妮斯·帕特洛米基·洛克斯嘉丽·约翰逊山姆·洛克威尔唐·钱德尔塞缪尔·杰克逊乔恩·费儒保罗·贝坦尼克拉克·格雷格凯特·玛拉约翰·斯拉特里 imdb:tt1228705 钢铁侠托尼·斯塔克（小罗伯特·唐尼 Robert Downey Jr. 饰）在国会听证上拒绝交出最新技术。与此同时，他发现胸口的微型电弧反应炉正迅速造成血液的钯金属中毒。沮丧的托尼将斯塔克公司的总裁职务交予了秘书波兹（格温妮丝·帕特罗 Gwyneth Paltrow 饰），由她全权负责正在进行的纽约斯塔克博览会。波兹从法律部门调来助理娜塔莉（斯佳丽·约翰逊 Scarlett Johansson 饰）照顾托尼。托尼在媒体前的高调亮相引起了其父当年同事的儿子，伊凡（米基·洛克 Mickey Rourke 饰）的不满。为了实施报复，他子承父业，研制出了一套可与钢铁战衣相媲美的装备。伊凡的技术引起了托尼的竞争对手，军火商贾斯丁·汉默（山姆·洛克威尔 Sam Rockwell 饰）的注意，他设法将伊凡劫持出狱，秘密研究取代钢铁侠。正当托尼苦于钯金属中毒造成的失意之时，他发现娜塔莉原来身负秘密使命，而自己的任性，也造成了与好友，空军上校罗尼（唐·钱德尔 Don Cheadle 饰）的反目，眼看局势就要失控…… 资源地址：http://www.pianyuan.la/m_DwwfWzcc0.html 钢铁侠3 Iron Man 3 (2013) 豆瓣评分 7.5 又名:铁甲奇侠3(港),钢铁人3(台),铁人3 地区:美国,中国大陆 类型:动作,科幻 导演:沙恩·布莱克 编剧:沙恩·布莱克德鲁·皮尔斯斯坦·李唐·赫克拉里·利伯杰克·科比 主演:小罗伯特·唐尼盖·皮尔斯格温妮斯·帕特洛本·金斯利唐·钱德尔保罗·贝坦尼丽贝卡·豪尔乔恩·费儒威廉姆·赛德勒詹姆斯·戴尔伊芳·齐玛泰·辛普金斯阿什利·汉弥尔顿王学圻范冰冰 imdb:tt1300854 自纽约事件以来，托尼·斯塔克（小罗伯特·唐尼 Robert Downey Jr. 饰）为前所未有的焦虑症所困扰。他疯狂投入钢铁侠升级版的研发，为此废寝忘食，甚至忽略了女友佩珀·波茨（格温妮斯·帕特洛 Gwyneth Paltrow 饰）的感受。与此同时，臭名昭著的恐怖头目曼达林（本·金斯利 Ben Kingsley 饰）制造了一连串的爆炸袭击事件，托尼当年最忠诚的保镖即在最近的一次袭击中身负重伤。未过多久，托尼、佩珀以及曾与他有过一面之缘的女植物学家玛雅（丽贝卡·豪尔 Rebecca Hall 饰）在家中遭到猛烈的炮火袭击，几乎丧命，而这一切似乎都与22年前那名偶然邂逅的科学家阿尔德里奇·基连（盖·皮尔斯 Guy Pearce 饰）及其终极生物的研究有关。 即使有精密先进的铠甲护身，也无法排遣发自心底的焦虑。被击碎一切的托尼，如何穿越来自地狱的熊熊烈火…… 资源地址：http://www.pianyuan.la/m_DttX0.html","categories":[{"name":"电影","slug":"电影","permalink":"http://yoursite.com/categories/%E7%94%B5%E5%BD%B1/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://yoursite.com/tags/%E7%94%B5%E5%BD%B1/"},{"name":"科幻","slug":"科幻","permalink":"http://yoursite.com/tags/%E7%A7%91%E5%B9%BB/"}],"keywords":[{"name":"电影","slug":"电影","permalink":"http://yoursite.com/categories/%E7%94%B5%E5%BD%B1/"}]},{"title":"电影-犯罪","slug":"电影-犯罪","date":"2020-05-02T12:49:22.000Z","updated":"2020-05-02T15:17:40.528Z","comments":true,"path":"2020/05/02/电影-犯罪/","link":"","permalink":"http://yoursite.com/2020/05/02/%E7%94%B5%E5%BD%B1-%E7%8A%AF%E7%BD%AA/","excerpt":"","text":"1. 暗夜逐仇 Run All Night (2015) 豆瓣评分 6.8 地区:美国 类型:剧情,动作,悬疑,惊悚,犯罪 导演:佐米·希尔拉 编剧:布拉德·英格尔斯比 主演:连姆·尼森乔尔·金纳曼珍尼希斯·罗德里格兹艾德·哈里斯尼克·诺特波伊德·霍布鲁克文森特·多诺费奥科曼布鲁斯·麦克吉尔博·纳普霍特·麦克卡兰尼帕特丽夏·考莱姆伯马尔科姆·古德温拉蒂沃杰·布克维奇詹姆斯·马丁内斯丹尼尔·斯图尔特·谢尔曼托尼·德文约翰·塞纳迭姆博Faye Yvette McQueen imdb:tt2199571 吉米（连姆·尼森 Liam Neeson 饰）是一位经验丰富，精明强干的职业杀手，效力于黑帮老大肖恩（艾德·哈里斯 Ed Harris 饰），两人合作多年，彼此之间结下了深厚的友谊。整日生活在鲜血和阴谋之后，吉米感到十分疲倦，他产生了想要“退休”的念头。 麦克（乔尔·金纳曼 Joel Kinnaman 饰）是吉米的儿子，父亲的特殊身份让两人的父子关系十分淡漠，然而，一场意外的发生让吉米杀死了肖恩的儿子丹尼（波伊德·霍布鲁克 Boyd Holbrook 饰），麦克亦成为了黑帮追杀的对象。为了保护儿子的安全，吉米重装上阵，和昔日旧友们展开了血腥厮杀。他们只有一夜的时间，一夜过去，吉米和麦克将会面临怎样的结局？ 资源地址：http://www.pianyuan.la/m_Dwb3Wcuc0.html 2. 最后的城堡 The Last Castle (2001) 豆瓣评分 7.8 地区:美国 类型:剧情,惊悚,犯罪 导演:F·加里·格雷 编剧:科特·维莫 主演:杰米·福克斯杰拉德·巴特勒科尔姆·米尼布鲁斯·麦克吉尔莱丝莉·比伯维奥拉·戴维斯 imdb:tt1197624 一座由城堡改建而来的军事监狱中迎来了一位重量级犯人——陆军将军埃尔文（罗伯特·雷德福 Robert Redford 饰），监狱长温特（James Gandolfini 饰）笑脸迎接，但很快开始厌恶对方身上的军人傲骨。埃尔文在监狱中听闻诸多温特的劣迹，但抱着安心服刑的心态让他并未多事，很快，温特剥夺军人尊严的惩罚激怒了埃尔文，埃尔文开始用自己的方式令众犯人找回尊严，并顺理成章成为犯人的领袖，感到自己受到威胁的温特愈发不可理喻，下令射杀一名犯人导致双方矛盾升级。 埃尔文决定组织实施监狱暴动，以使上级部门介入对温特的调查。这些昔日的军人、如今的犯人们抱着重新回到战场的觉悟，在高度组织和秘密的情况下完成了作战的准备，一次双重间谍的任务成功之后，犯人军团吹响了夺取监狱的号角！ 资源地址：http://www.pianyuan.la/m_Dw8xEH2c0.html 3. 守法公民 Law Abiding Citizen (2009) 豆瓣评分 8.0 又名:重案对决,知法玩法 地区:美国 类型:剧情,惊悚,犯罪 导演:F·加里·格雷 编剧:科特·维莫 主演:杰米·福克斯杰拉德·巴特勒科尔姆·米尼布鲁斯·麦克吉尔莱丝莉·比伯维奥拉·戴维斯 imdb:tt1197624 克莱德·谢尔顿（格莱德·巴特勒 Gerard Butler 饰）是居住在费城某小镇的一名研发人员，他有着美丽的妻子和可爱的女儿，生活幸福美满。但这一切都被突如其来的灾难所摧毁。某晚，两个暴徒闯入他的家中，妻子和女儿都受到残害。然而虽然证据确凿，但由于司法程序的迂腐和尼克·瑞斯（杰米·福克斯 Jamie Foxx 饰）助理执行官的堕落，最终让首犯克拉伦斯·多比（克里斯蒂安·斯多特 Christian Stolte 饰）因证据不足只得到10年徒刑。 本以为一切归于沉寂，但10年后当年未了的风波再起。怀着巨大仇恨的克莱德开始筹划展开报复，先是干掉了当年的从犯阿米，接着他很快找到了邪恶无耻的多比，并对其进行残酷的折磨与虐杀。克莱德的仇恨得到巨大的宣泄，但是他的复仇还未就此停止。他所针对的不只是那两个暴徒，而是整个腐朽堕落的司法系统…… 资源地址：http://www.pianyuan.la/m_685xczcc0.htm 4. 惩罚者 The Punisher (2004) 豆瓣评分 6.5 又名:神鬼制裁,制裁者 地区:美国,德国 类型:剧情,动作,惊悚,犯罪 导演:Jonathan Hensleigh 编剧:Jonathan HensleighMichael France 主演:托马斯·简约翰·特拉沃尔塔威尔·帕顿丽贝卡·罗梅恩本·福斯特 imdb:tt0330793 弗兰克·卡斯特（托马斯·简 Thomas Jane 饰）的生命中，绝大部分时间都在于死神赛跑。早年在海军陆战队服役，退役后又进入FBI。在枪炮火光中生活了多年之后，弗兰克不愿再整日收到死亡的威胁，家人整日为他担惊受怕。所以，他决定提前退休与妻儿享受平静的生活。可是，在最后的一次任务中，却因意外使一名无辜青年死亡。而这名青年的父亲却是坦帕市的大富商霍华德·桑特（约翰·特拉沃塔 John Travolta 饰）。为了给儿子报仇，霍华德向黑市发出了对弗兰克一家的绞杀令。不过弗兰克却侥幸在这场浩劫中存活下来。为了报仇，弗兰克不再寄望于法制，而是全副武装向霍华德发起挑战。面对霍华德组建的私人军队，弗兰克凭一己之力将如何应对？ 资源地址：http://www.pianyuan.la/m_68wcEzcc0.html 5.鹰眼 Eagle Eye (2008) 豆瓣评分 7.0 又名:鹰眼追击 地区:美国,德国 类型:动作,悬疑,惊悚 导演:D·J·卡卢索 编剧:约翰·格里恩Travis Wright 主演:希亚·拉博夫罗莎里奥·道森米歇尔·莫娜汉比利·鲍伯·松顿伊桑·恩布里 imdb:tt1059786 中东某地，美国军方的情报系统锁定了一名目标人物，总统不顾系统电脑运算出的建议处理方式，下令定点清除，由此引发了意外的连锁反应……公司小职员杰瑞（Shia LaBeouf 饰）的生活平淡乏味，时常手头拮据，连房租也成了问题，由于供职于军方的孪生兄弟意外过世，杰瑞赶回家中参加葬礼，但此行归来后，杰瑞发现家中居然堆满了武器，随即赶到的FBI破窗而入将他逮捕。与此同时，名叫蕾切尔（Michelle Monaghan 饰）的女人从大街上的电子广告牌上得知自己的儿子被某人绑架，绑架者拥有超乎寻常的能力，能够控制电子产品并监控一切。这名绑架者引导杰瑞摆脱FBI，最终上了蕾切尔的车，两名陌生人被迫合作，在FBI的追捕中落入了神秘绑架者的计划……究竟绑架者是谁？他又有何居心呢？ 资源地址：http://www.pianyuan.la/m_S85xWFcc0.html 6.抓住外国佬 Get the Gringo (2012) 豆瓣评分 7.4 又名:狱中无人(港),我如何度过暑假,How I Spent My Summer Vacation 地区:美国 类型:剧情,动作,犯罪 导演:阿德里安·格鲁伯格 编剧:阿德里安·格鲁伯格梅尔·吉布森 主演:梅尔·吉布森彼得·斯特曼迪恩·诺里斯鲍勃·冈顿索菲亚·斯尼加斯科特·科恩凯文·赫尔南德斯德洛丽丝·赫雷迪亚帕特里克·波查斯蒂芬妮·勒梅林 imdb:tt1567609 影片讲述了一个职业罪犯（梅尔·吉布森 Mel Gibson 饰）被墨西哥警方抓捕后送往一个充满毒品和犯罪的监狱，在一个9岁男孩的帮助下，他学会了如何在这样的监狱里生存下来。 本片由梅尔·吉布森和《启示》（Apocalypto）的原班人马在墨西哥的伊格阿连德监狱拍摄完成。梅尔 ·吉布森不会亲自执导这部影片，而是让《启示》的第一助理导演Ad rian Grunberg来当导演。不过这部影片的剧本是吉布森自己创作的，而且他也将亲自主演。 资源地址：http://www.pianyuan.la/m_DmwcWQcc0.html 劫案迷云 Stolen (2012) 豆瓣评分 6.1 又名:盗数计时(台),被窃之物,勋章,Medallion 地区:美国 类型:剧情,动作,惊悚,犯罪 导演:西蒙·韦斯特 编剧:大卫·古根海姆 主演:尼古拉斯·凯奇玛琳·阿克曼乔什·卢卡斯丹尼·赫斯顿马克·瓦雷萨米·盖尔 imdb:tt1656186 威尔·蒙哥马利（尼古拉斯·凯奇 Nicolas Cage 饰）的四人盗窃团伙在一次行窃银行金库时被埋伏在现场的FBI逮个正着，同伙文森特在混乱中中枪，而威尔将赃款付之一炬后独自被捕。八年后，威尔出狱，迎接他的是怀疑他当年私藏赃款的FBI探员安德森，以及女儿艾莉森（ 萨米·盖尔 Sami Gayle 饰）的敌视，威尔心力憔悴之际突然收到了文森特绑架艾莉森的消息。原来当年行窃失败后文森特陷入潦倒，为了讨还一千万中属于自己的部分他绑架了艾莉森。威尔试图向FBI求助却不被安德森信任，无奈只得独自拯救女儿，为此他不惜找到当年的搭档蕾莉(玛琳·阿克曼 Malin Akerman 饰)，准备再次犯案…… 资源地址：http://www.pianyuan.la/m_DmbXcpcc0.html 骗局 The Hoax (2006) 豆瓣评分 6.6 又名:大亨伪传,欺世盗名 地区:美国 类型:剧情,喜剧 导演:莱塞·霍尔斯道姆 编剧:威廉·惠勒 主演:理查·基尔朱莉·德尔佩霍普·戴维斯 imdb:tt0462338 无人不知的美国大亨霍华德·休斯在晚年过起了隐居生活，在人们的心中愈加神秘，然而有关他的任何一点新闻都会牵动美国人的神经。 这次引起轰动的是一个小作家艾尔文（理查·基尔），他声称得到授权为休斯写回忆录。新闻每天追踪着关于休斯的各种消息，休斯的传记也如约出版。艾尔文因此一夜致富，闻名全美。就在这一切进行的如火如荼时，艾尔文和他的亲友却感到惴惴不安，因为一切都是假的。他们根本没见过休斯，更没有什么授权，他们只是为了一个谎又扯一个谎，最终织成了弥天大谎。或许更让艾尔文悲哀的是，他已经难分生活的真实与虚假，他编造着别人的生活，也让自己走入了谎言的陷阱。 资源地址：http://www.pianyuan.la/m_6mtNczcc0.html 焦点 Focus (2015) 豆瓣评分 6.5 又名:决胜焦点(台),千骗万化 (港) 地区:美国 类型:剧情,喜剧,犯罪 导演:格伦·费卡拉约翰·里夸 编剧:格伦·费卡拉约翰·里夸 主演:玛格特·罗比威尔·史密斯罗德里格·桑托罗黄荣亮杰拉尔德·麦克雷尼罗伯特·泰勒乔·克里斯特多米尼克·福穆萨Christopher HeskeyStephanie HonoréAdrian MartinezLaura FlanneryBrennan BrownJustin LebrunDon Yesso imdb:tt2381941 威尔史密斯所饰演的尼基是一名经验丰富的诱导术大师，他善于赢得人们的信任，并将这种技巧视为一种专门的学问，当他遇见新手洁丝(玛格罗比 饰演)，在她的央求之下，他终于引领她进入犯罪的殿堂，聪明、美丽又懂心机的杰丝很快成为个中高手。三年后，当尼基准备进行他这一生中最大，最缜密也最复杂危险的一场骗局时，洁丝突然出现，不管她究竟是敌是友，尼基知道，她将可能是行动成功与否最大的变数。 资源地址：http://www.pianyuan.la/m_DwbXWf6c0.html 窗台上的男人 Man on a Ledge (2012) 豆瓣评分 7.1 又名:惊天换日(台),天际100分钟(港),顶楼救援 地区:美国 类型:惊悚,犯罪 导演:阿斯各·莱斯 编剧:埃里希·霍贝尔乔·霍贝尔Chris GorakPablo F. Fenjves 主演:萨姆·沃辛顿伊丽莎白·班克斯杰米·贝尔艾德·哈里斯安东尼·麦凯爱德华·伯恩斯提图斯·维里沃珍尼希斯·罗德里格兹凯拉·塞吉维克 imdb:tt1568338 尼克·卡西迪（萨姆·沃辛顿 Sam Worthington 饰）曾经是一名正直负责的警察，却因涉嫌盗窃4000万美元的钻石而获刑25年监禁。他唯一一个离开监狱的机会就是参加父亲葬礼，并在葬礼上趁机逃跑。然而令人不解的是，他并没有出境，而是到曼哈顿酒店开了个24楼的房间，精心擦洗一番后，只为在最繁华的纽约的注视中坠楼。他的举动很快引来了大批警察和媒体，一名年轻的谈判专家莉迪亚（伊丽莎白·班克斯 Elizabeth Banks 饰）试图将其劝回屋内，然而在循序渐进的劝说中，莉迪亚意识到尼克是被钻石的拥有者大卫（艾德·哈里斯 Ed Harris 饰）陷害入狱的，目的则是为了高额保险金。然而更令莉迪亚想不到的是，尼克的自杀只是一个声东击西的幌子，他的弟弟和女友正在街对面的珠宝库大楼中实施复仇计划…… 资源地址：http://www.pianyuan.la/m_Dw8zEzcc0.html 银行匪帮 Takers (2010) 豆瓣评分 6.9 又名:劫匪,狭路相逢,偷天抢地,Bone Deep 地区:美国 类型:动作,惊悚,犯罪 导演:John Luessenhop 编剧:Peter Allen加布里埃尔·卡塞斯Avery DuffJohn Luessenhop 主演:马特·狄龙保罗·沃克海登·克里斯滕森克里斯·布朗佐伊·索尔达娜迈克尔·伊雷伊德里斯·艾尔巴杰伊·赫尔南德兹T.I. imdb:tt1135084 戈登（Idris Elba 饰）等五人组成的银行抢劫团伙每隔一年作案一次，其成员AJ（海登•克里斯滕森 Hayden Christensen 饰）、约翰（保罗•沃克 Paul Walker 饰）各有所长，抢劫所得和合理的投资令他们过着奢华的生活。在最近的一次劫案中，他们引起了铁腕警探杰克（马特•狄龙 Matt Dillon 饰）的注意。 戈登团伙昔日的成员里弗斯新近出狱，里弗斯在狱中结识了俄罗斯黑帮，并取得一份银行的内线情报。里弗斯邀请众人行劫，否则就拿回当年属于自己的那份抢劫所得，尽管时间仓促，不符合团伙一贯的行事风格，然而一番讨论之下，他们决定再次出手。与此同时，杰克以抢劫所用的C4炸药为突破口，发现了这次有俄罗斯黑帮参与的抢劫计划图纸。距离计划时间所剩无几，这次抢劫会导致怎样的结局？ 资源地址：http://www.pianyuan.la/m_DwoxEzcc0.html","categories":[{"name":"电影","slug":"电影","permalink":"http://yoursite.com/categories/%E7%94%B5%E5%BD%B1/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://yoursite.com/tags/%E7%94%B5%E5%BD%B1/"},{"name":"犯罪","slug":"犯罪","permalink":"http://yoursite.com/tags/%E7%8A%AF%E7%BD%AA/"}],"keywords":[{"name":"电影","slug":"电影","permalink":"http://yoursite.com/categories/%E7%94%B5%E5%BD%B1/"}]},{"title":"Kafka命令行操作","slug":"Kafka命令行操作","date":"2020-05-02T11:27:08.000Z","updated":"2020-05-02T12:47:41.338Z","comments":true,"path":"2020/05/02/Kafka命令行操作/","link":"","permalink":"http://yoursite.com/2020/05/02/Kafka%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C/","excerpt":"","text":"Kafka命令行操作 查看当前服务器中的所有topic 12[root@hadoop141 kafka]# bin&#x2F;kafka-topics.sh --zookeeper hadoop141:2181 --list[root@hadoop141 kafka]# 为空 因为还没有创建topic 创建topic 12[root@hadoop141 kafka]# bin&#x2F;kafka-topics.sh --zookeeper hadoop141:2181 --create --partitions 2 --replication-factor 2 --topic firstCreated topic &quot;first&quot;. 选项说明： –create：创建命令 –partitions：定义分区数 –replication-factor：定义副本数 –topic：定义 topic 名 进入 logs 文件夹 可以看到创建得 topic 123456789[root@hadoop141 kafka]# ll logs&#x2F;drwxr-xr-x 2 root root 4096 5月 2 17:00 first-0drwxr-xr-x 2 root root 4096 5月 2 17:00 first-1[root@hadoop142 kafka]# ll logs&#x2F;drwxr-xr-x. 2 root root 4096 5月 2 17:00 first-1[root@hadoop143 kafka]# ll logs&#x2F;drwxr-xr-x. 2 root root 4096 5月 2 17:00 first-0 可以看出 first 有两个分区 -0 -1，而且每个分区有两个副本。 注意事项： 当你设置的副本数量大于你配置的服务器数量(我的是3个)时：–replication-factor 4 会报错，所以 Kafka不像Hadoop那样可以配置超过服务器的数量 1234[root@hadoop141 kafka]# bin&#x2F;kafka-topics.sh --zookeeper hadoop141:2181 --create --partitions 3 --replication-factor 4 --topic firstError while executing topic command : replication factor: 4 larger than available brokers: 3[2020-05-02 17:16:12,981] ERROR org.apache.kafka.common.errors.InvalidReplicationFactorException: replication factor: 4 larger than available brokers: 3 (kafka.admin.TopicCommand$) 删除 topic 123[root@hadoop141 kafka]# bin&#x2F;kafka-topics.sh --zookeeper hadoop141:2181 --delete --topic firstTopic first is marked for deletion.Note: This will have no impact if delete.topic.enable is not set to true 需要server.properties中设置delete.topic.enable=true否则只是标记删除 12#删除topic功能使能delete.topic.enable&#x3D;true 这个选项设置为 true 的话 topic 会被删除掉 查看 logs/ 文件夹发现 first 已经被删除。 发送消息 123[root@hadoop141 kafka]# bin&#x2F;kafka-console-producer.sh --broker-list hadoop141:9092 --topic first&gt;hello&gt;world 消费消息 123[root@hadoop142 kafka]# bin&#x2F;kafka-console-consumer.sh --bootstrap-server hadoop141:9092 --from-beginning --topic firsthelloworld –from-beginning：会把主题中以往所有的数据都读取出来 查看某个Topic的详情 12345[root@hadoop143 kafka]# bin&#x2F;kafka-topics.sh --zookeeper hadoop141:2181 --describe --topic firstTopic:first PartitionCount:2 ReplicationFactor:3 Configs: Topic: first Partition: 0 Leader: 1 Replicas: 1,2,0 Isr: 1,2,0 Topic: first Partition: 1 Leader: 2 Replicas: 2,0,1 Isr: 2,0,1You have new mail in &#x2F;var&#x2F;spool&#x2F;mail&#x2F;root PartitionCount ReplicationFactor Configs 分区 副本 配置信息 修改分区数 123[root@hadoop143 kafka]# bin&#x2F;kafka-topics.sh --zookeeper hadoop141:2181 --alter --topic first --partitions 5WARNING: If partitions are increased for a topic that has a key, the partition logic or ordering of the messages will be affectedAdding partitions succeeded! 查看 logs/ 文件夹: 12345drwxr-xr-x. 2 root root 4096 5月 2 17:33 first-0drwxr-xr-x. 2 root root 4096 5月 2 17:31 first-1drwxr-xr-x. 2 root root 4096 5月 2 17:40 first-2drwxr-xr-x. 2 root root 4096 5月 2 17:40 first-3drwxr-xr-x. 2 root root 4096 5月 2 17:40 first-4","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"Kafka","slug":"框架/BigData/Kafka","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/Kafka/"}],"tags":[{"name":"Kafka","slug":"Kafka","permalink":"http://yoursite.com/tags/Kafka/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"Kafka","slug":"框架/BigData/Kafka","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/Kafka/"}]},{"title":"LeetCode| 1099. 小于 K 的两数之和","slug":"LeetCode - 1099 小于 K 的两数之和","date":"2020-05-02T10:59:00.000Z","updated":"2020-05-04T09:13:40.508Z","comments":true,"path":"2020/05/02/LeetCode - 1099 小于 K 的两数之和/","link":"","permalink":"http://yoursite.com/2020/05/02/LeetCode%20-%201099%20%E5%B0%8F%E4%BA%8E%20K%20%E7%9A%84%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"LeetCode 图解 | 1099. 小于 K 的两数之和 题目描述 给你一个整数数组 A 和一个整数 K，请在该数组中找出两个元素，使它们的和小于 K 但尽可能地接近 K，返回这两个元素的和。 如不存在这样的两个元素，请返回 -1。 示例 1： 1234输入：A &#x3D; [34,23,1,24,75,33,54,8], K &#x3D; 60输出：58解释：34 和 24 相加得到 58，58 小于 60，满足题意。 示例 2： 1234输入：A &#x3D; [10,20,30], K &#x3D; 15输出：-1解释：我们无法找到和小于 15 的两个元素。 提示： 1 &lt;= A.length &lt;= 100 1 &lt;= A[i] &lt;= 1000 1 &lt;= K &lt;= 2000 题目解析 传统的 TwoSum 都是要你找到等于 target 的配对，那么如果说要找到 大于/小于 target 的配对呢？ 这个时候 Hash 表的方法就很难 work 了，因为 Hash 表比较适合处理 等于 的情况 ！ 那么就需要考虑如何使用排序加双指针的方法来解决这个问题，这里，题目是要求小于 target 的数量，我们还是按照之前的分析思路来分析。 如果说当前左右指针指向的元素的和大于或者等于 target，那么势必我们需要向左移动右指针，让两个元素的和尽可能地小，当前头尾指针指向的元素和小于 target 的时候，这时我们需要记录答案，虽然这道题目里面没提，如果说要记录配对数量的话，这时并不是记录一个答案，如果说当前左指针固定，除了当前的右指针指向的元素，在左指针和右指针之间的数都是满足要求的，我们只需要加上这个区间的数量即可，当然如果数组中存在重复元素，那么我们就需要按照之前的套路遍历去重了，当然对于这道题来说，我们选择满足条件的最大值即可。 代码实现 123456789101112131415161718192021public int twoSumLessThanK(int[] A, int K) &#123; if (A == null || A.length == 0) &#123; return -1; &#125; Arrays.sort(A); int l = 0, r = A.length - 1; int result = Integer.MIN_VALUE; while (l &lt; r) &#123; if (A[l] + A[r] &gt;= K) &#123; r--; &#125; else &#123; result = Math.max(result, A[l] + A[r]); l++; &#125; &#125; return result == Integer.MIN_VALUE ? -1 : result;&#125; 转至：https://mp.weixin.qq.com/s/rnYcJGX4WFGpESbITmok1Q","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95/LeetCode/"}]},{"title":"Kafka安装部署","slug":"Kafka安装部署","date":"2020-05-02T10:59:00.000Z","updated":"2020-05-02T11:09:57.675Z","comments":true,"path":"2020/05/02/Kafka安装部署/","link":"","permalink":"http://yoursite.com/2020/05/02/Kafka%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/","excerpt":"","text":"Kafka安装部署 集群规划 主机 Hadoop141 Hadoop142 Hadoop143 集群 ZK ZK ZK 集群 Kafka Kafka Kafka jar包下载 http://kafka.apache.org/downloads.html 集群部署 1、解压安装包 1[root@hadoop141 software]# tar -zxvf kafka_2.11-0.11.0.0.tgz &#x2F;opt&#x2F;module&#x2F; 2、修改解压文件 1[root@hadoop141 module]# mv kafka_2.11-0.11.0.0&#x2F; kafka 3、在/opt/module/kafka 目录下创建 logs 文件夹 12345678910[root@hadoop141 kafka]# mkdir logs[root@hadoop141 kafka]# ll总用量 56drwxr-xr-x 3 root root 4096 6月 23 2017 bindrwxr-xr-x 2 root root 4096 6月 23 2017 configdrwxr-xr-x 2 root root 4096 5月 2 15:13 libs-rw-r--r-- 1 root root 28824 6月 23 2017 LICENSEdrwxr-xr-x 2 root root 4096 5月 2 15:41 logs-rw-r--r-- 1 root root 336 6月 23 2017 NOTICEdrwxr-xr-x 2 root root 4096 6月 23 2017 site-docs 4、修改配置文件 1[root@hadoop141 kafka]# vim config&#x2F;server.properties 5、修改一下内容 123456789101112131415161718192021222324#broker的全局唯一编号，不能重复broker.id=0#删除topic功能使能delete.topic.enable=true#处理网络请求的线程数量num.network.threads=3#用来处理磁盘IO的现成数量num.io.threads=8#发送套接字的缓冲区大小socket.send.buffer.bytes=102400#接收套接字的缓冲区大小socket.receive.buffer.bytes=102400#请求套接字的缓冲区大小socket.request.max.bytes=104857600#kafka运行日志存放的路径 log.dirs=/opt/module/kafka/logs#topic在当前broker上的分区个数num.partitions=1#用来恢复和清理data下数据的线程数量num.recovery.threads.per.data.dir=1#segment文件保留的最长时间，超时将被删除log.retention.hours=168#配置连接Zookeeper集群地址zookeeper.connect=hadoop141:2181,hadoop142:2181,hadoop143:2181 6、配置环境变量 1[root@hadoop141 kafka]# vim &#x2F;etc&#x2F;profile 添加以下内容： 123#KAFKA_HOMEexport KAFKA_HOME=/opt/module/kafkaexport PATH=$PATH:$KAFKA_HOME/bin 7、分发安装包 1[root@hadoop141 module]# xrsync.sh kafka&#x2F; 注意：分发之后记得配置其他机器的环境变量 8 、分别在hadoop142和hadoop143上修改配置文件/opt/module/kafka/config/server.properties中的broker.id=1、broker.id=2 注：broker.id不得重复 9、 启动集群 依次在hadoop141、hadoop142、hadoop143节点上启动kafka 启动之前 先启动3台节点得 zookeeper： 12345[root@hadoop141 kafka]# cd &#x2F;opt&#x2F;module&#x2F;zookeeper-3.4.10&#x2F;[root@hadoop141 zookeeper-3.4.10]# bin&#x2F;zkServer.sh startZooKeeper JMX enabled by defaultUsing config: &#x2F;opt&#x2F;module&#x2F;zookeeper-3.4.10&#x2F;bin&#x2F;..&#x2F;conf&#x2F;zoo.cfgStarting zookeeper ... STARTE 然后启动Kafka： 123[root@hadoop141 kafka]# bin&#x2F;kafka-server-start.sh -daemon config&#x2F;server.properties[root@hadoop142 kafka]# bin&#x2F;kafka-server-start.sh -daemon config&#x2F;server.properties[root@hadoop143 kafka]# bin&#x2F;kafka-server-start.sh -daemon config&#x2F;server.properties 启动成功： 12345678910111213[root@hadoop141 kafka]# xcall.sh jps&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; hadoop141 jps &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;3657 Kafka3338 QuorumPeerMain3759 Jps&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; hadoop142 jps &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;3573 Jps3526 Kafka3215 QuorumPeerMain&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; hadoop143 jps &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;3602 Jps3214 QuorumPeerMain3518 Kafka 10、 关闭集群 123[atguigu@hadoop141 kafka]$ bin&#x2F;kafka-server-stop.sh stop[atguigu@hadoop142 kafka]$ bin&#x2F;kafka-server-stop.sh stop[atguigu@hadoop143 kafka]$ bin&#x2F;kafka-server-stop.sh stop 11、kafka集群启动脚本 1[root@hadoop141 bin]# vim &#x2F;bin&#x2F;kk.sh 123456789101112131415161718192021222324252627#!/bin/basharg=$#if((arg==0));thenecho no args;exit;ficase $1 in\"start\")&#123; for i in 'cat /opt/module/hadoop-2.7.2/etc/hadoop/slaves' do echo \"========== $i ==========\" ssh $i 'source /etc/profile&amp;&amp;/opt/module/kafka/bin/kafka-server-start.sh -daemon /opt/module/kafka/config/server.properties' echo $? done&#125;;;\"stop\")&#123; for i in 'cat /opt/module/hadoop-2.7.2/etc/hadoop/slaves' do echo \"========== $i ==========\" ssh $i 'source /etc/profile&amp;&amp;/opt/module/kafka/bin/kafka-server-stop.sh -daemon /opt/module/kafka/config/server.properties' echo $? done&#125;;;esac 12345678910111213141516171819202122232425#!/bin/basharg=$#if((arg==0));thenecho no args;exit;ficase $1 in\"start\")&#123; for i in hadoop141 hadoop142 hadoop143 do echo \"========== $i ==========\" ssh $i \"/opt/module/kafka/bin/kafka-server-start.sh -daemon /opt/module/kafka/config/server.properties\" done&#125;;;\"stop\")&#123; for i in hadoop141 hadoop142 hadoop143 do echo \"========== $i ==========\" ssh $i \"/opt/module/kafka/bin/kafka-server-stop.sh\" done&#125;;;esac 修改权限： 1[root@hadoop141 bin]# chmod 777 kk.sh","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"Kafka","slug":"框架/BigData/Kafka","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/Kafka/"}],"tags":[{"name":"Kafka","slug":"Kafka","permalink":"http://yoursite.com/tags/Kafka/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"BigData","slug":"框架/BigData","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/"},{"name":"Kafka","slug":"框架/BigData/Kafka","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/BigData/Kafka/"}]},{"title":"Spring - 装配Spring Bean-通过注解（自动装配-@Autowired）","slug":"Spring-装配Spring-Bean-通过注解（自动装配-Autowired）","date":"2020-05-01T15:56:58.000Z","updated":"2020-05-01T15:57:31.276Z","comments":true,"path":"2020/05/01/Spring-装配Spring-Bean-通过注解（自动装配-Autowired）/","link":"","permalink":"http://yoursite.com/2020/05/01/Spring-%E8%A3%85%E9%85%8DSpring-Bean-%E9%80%9A%E8%BF%87%E6%B3%A8%E8%A7%A3%EF%BC%88%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D-Autowired%EF%BC%89/","excerpt":"","text":"自动装配-@Autowired 在上一节中还有一个对象注入问题没有解决，关于这个问题，在大部分情况下建议使用自动装配，可以减小配置的复杂度。 通过学习Spring IOC容器，我们知道Spring是先完成Bean的定义和生成，然后当Spring生成所有的Bean后，如果发现注解@AutoWired，他就会在Bean中查找，然后找到对应的类型，将其注入。 实现自动装配 定义实体类，Role.java 1234567891011121314151617package com.ssm.annotation.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component(value = \"role\")public class Role &#123; @Value(\"1\") private Long idLong; @Value(\"roleName1\") private String roleNameString; @Value(\"note1\") private String noteString; /*省略get和set方法*/&#125; 生成一个Service接口 12345package com.ssm.annotation.service;public interface RoleService &#123; public void printRoleInfo();&#125; 生成Service接口实现类 1234567891011121314151617181920212223package com.ssm.annotation.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import com.ssm.annotation.pojo.Role;import com.ssm.annotation.service.RoleService;@Componentpublic class RoleServiceImpl implements RoleService&#123; @Autowired private Role role = null; public Role getRole() &#123; return role; &#125; public void setRole(Role role) &#123; this.role = role; &#125; @Override public void printRoleInfo() &#123; System.out.println(\"RoleServiceImpl\"+role.toString()); &#125;&#125; 这里的注解@AutoWired，表示在Spring IOC中定位的所有Bean后，到Sring IOC容器中按照类型查找对应的实例并将其注入。 扫描组件类 12345678package com.ssm.annotation.config;import org.springframework.context.annotation.ComponentScan;import com.ssm.annotation.pojo.Role;import com.ssm.annotation.service.impl.RoleServiceImpl;@ComponentScan(basePackageClasses = &#123;Role.class,RoleServiceImpl.class&#125;,basePackages = &#123;\"com.ssm.annotation.pojo\",\"com.ssm.annotation.service\"&#125;)public class PojoConfig &#123;&#125; 测试类 1234567891011121314151617package com.ssm.annotation.test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import com.ssm.annotation.config.PojoConfig;import com.ssm.annotation.pojo.Role;import com.ssm.annotation.service.RoleService;public class AnnotationTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationConfigApplicationContext(PojoConfig.class); Role role = context.getBean(Role.class); RoleService roleService =context.getBean(RoleService.class); roleService.printRoleInfo(); &#125;&#125; 测试结果 1RoleServiceImplRole [idLong=1, roleNameString=roleName1, noteString=note1] 注：@AutoWired注解除了可以配置在属性上之外，还可以配置到方法上 1234567891011121314151617@Componentpublic class RoleServiceImpl implements RoleService&#123; private Role role = null; public Role getRole() &#123; return role; &#125; @Autowired public void setRole(Role role) &#123; this.role = role; &#125; @Override public void printRoleInfo() &#123; System.out.println(\"RoleServiceImpl\"+role.toString()); &#125;&#125;","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"SSM","slug":"框架/SSM","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/SSM/"},{"name":"Spring","slug":"框架/SSM/Spring","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/SSM/Spring/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"SSM","slug":"框架/SSM","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/SSM/"},{"name":"Spring","slug":"框架/SSM/Spring","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/SSM/Spring/"}]},{"title":"Spring - 装配Spring Bean-通过注解（组件扫描）","slug":"Spring-装配Spring-Bean-通过注解（组件扫描）","date":"2020-05-01T15:54:58.000Z","updated":"2020-05-01T16:07:35.170Z","comments":true,"path":"2020/05/01/Spring-装配Spring-Bean-通过注解（组件扫描）/","link":"","permalink":"http://yoursite.com/2020/05/01/Spring-%E8%A3%85%E9%85%8DSpring-Bean-%E9%80%9A%E8%BF%87%E6%B3%A8%E8%A7%A3%EF%BC%88%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F%EF%BC%89/","excerpt":"","text":"Annotation 通过注解（Annotation）去装配Soring Bean，可以减少对XML文件的配置，注解功能更为强大，他既能实现XML的功能，也能提供自动装配的功能。 方式 方式 作用 组件扫描(@Component与@ComponentScan) 通过定义资源的方式，让Spring IOC容器扫描对应的包，从而把Bean装配出来 自动装配（@Autowired） 通过注解定义，使得一些依赖关系可以通过注解完成 组件扫描 使用@Component装配Bean 首先定义一个POJO类，Role.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.ssm.annotation.pojo;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Component;@Component(value = \"role\")public class Role &#123; @Value(\"1\") private Long idLong; @Value(\"roleName1\") private String roleNameString; @Value(\"note1\") private String noteString; public Long getIdLong() &#123; return idLong; &#125; public void setIdLong(Long idLong) &#123; this.idLong = idLong; &#125; public String getRoleNameString() &#123; return roleNameString; &#125; public void setRoleNameString(String roleNameString) &#123; this.roleNameString = roleNameString; &#125; public String getNoteString() &#123; return noteString; &#125; public void setNoteString(String noteString) &#123; this.noteString = noteString; &#125; @Override public String toString() &#123; return \"Role [idLong=\" + idLong + \", roleNameString=\" + roleNameString + \", noteString=\" + noteString + \"]\"; &#125;&#125; 1.注解@Component代表Spring IoC会把这个类扫描生成Bean实例， 其中value代表这个类在Spring中的ID,value可以省略不写@Component（&quot;role&quot;）,也可以直接写成@Component，Spring IOC会默认为类名，但是id会变成首字母小写的类名（”role“）。 2.注解@Value代表是值的注入。 定义一个Java Config类，好让Spring IOC知道要去哪里扫描对象 123456package com.ssm.pojo;import org.springframework.context.annotation.ComponentScan;@ComponentScanpublic class PojoConfig &#123;&#125; 1.包名要和POJO保持一致（就是Java Conofig类要和POJO类在同一个包下）。 2.@ComponentScan代表进行扫描，默认是扫描当前包的路径。 测试类 123456789101112131415package com.ssm.pojo.test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import com.ssm.pojo.PojoConfig;import com.ssm.pojo.Role;public class test &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationConfigApplicationContext(PojoConfig.class); Role role = context.getBean(Role.class); System.out.print(role.toString()); &#125;&#125; 这里使用AnnotationConfigApplicationContext生成IOC容器，并获取PojoConfig.java类中扫描的对象。 运行结果 1Role [idLong=1, roleNameString=roleName1, noteString=note1] 通过上面的简单编写你会发现两个弊端： 对于@ComponentScan注解，你会发现他只是扫描所在java类的包，不能扫描指定的包 上面的注入只有值的注入，但是大部分需要的是对象的注入 所以为了解决这第一个问题（包的扫描），我们可以在@ComponentScan中引用两个配置项 basePackages basePackageClasses 配置项 作用 basePackages 可以配置一个Java包的数组，Spring会根据配置去扫描对应的包和子包，把配置好的Bean装配进来 basePackageClasses 可以配置多个Java类，会根据类所在的包，为该包和子包进行扫描装配对应配置的Bean @ComponentScan的使用 实体类POJO还是上面的Role.java 然后定义一个service接口 1234567package com.ssm.annotation.service;import com.ssm.annotation.pojo.Role;public interface RoleService &#123; public void printRoleInfo(Role role);&#125; 实现RoleService接口 1234567891011121314package com.ssm.annotation.service.impl;import org.springframework.stereotype.Component;import com.ssm.annotation.pojo.Role;import com.ssm.annotation.service.RoleService;@Componentpublic class RoleServiceImpl implements RoleService&#123; @Override public void printRoleInfo(Role role) &#123; System.out.println(role.toString()); &#125;&#125; 对Java Config类配置@ComponentScan 12345678910111213141516package com.ssm.annotation.config;import org.springframework.context.annotation.ComponentScan;import com.ssm.annotation.pojo.Role;import com.ssm.annotation.service.impl.RoleServiceImpl;//通过@ComponentScan中的basePackageClasses配置项，可以获取配置的类所在的包，为包和子包进行扫描装配对应配置的Bean//@ComponentScan(basePackageClasses = &#123;Role.class,RoleServiceImpl.class&#125;)//通过@ComponentS阿产能中的basePackages配置项，可以配置一个java包的数组，Spring会根据他的配置扫描对应的包和子包//@ComponentScan(basePackages = &#123;\"com.ssm.annotation.pojo\",\"com.ssm.annotation.service\"&#125;)//组合使用@ComponentScan(basePackageClasses = &#123;Role.class,RoleServiceImpl.class&#125;,basePackages = &#123;\"com.ssm.annotation.pojo\",\"com.ssm.annotation.service\"&#125;)public class PojoConfig &#123;&#125; 上面通过三种方式进行了配置： 1.basePackageClassess采用的是对包的扫描，他会扫描该包和子包，将配置好的Bean装配进来 2.basePackages 会对java包的数组进行扫描，并扫描对应的包和子包 注意： 对于扫描包的定义，可以采用任意一个@ComponentScan去定义，但是最好只定义一个@ComponentScan， 因为每定义一个@ComponentScan，Spring就会为所定义的类去生成一个新的对象，也就是所配置的Bean将会生成多个实例。 对于同一个@ComponentScan中部的basePackageClasses和basePackages，Spring会进行专门的区分， 也就是说在同一个@ComponentScan中即使你重复定义相同的包或者子包，也不会造成因同一个Bean的多次扫描，而导致一次配置会生成多个对象的情况。 测试类 1234567891011121314151617package com.ssm.annotation.test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import com.ssm.annotation.config.PojoConfig;import com.ssm.annotation.pojo.Role;import com.ssm.annotation.service.RoleService;public class AnnotationTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new AnnotationConfigApplicationContext(PojoConfig.class); Role role = context.getBean(Role.class); RoleService roleService =context.getBean(RoleService.class); roleService.printRoleInfo(role); &#125;&#125; 运行结果 1Role [idLong=1, roleNameString=roleName1, noteString=note1] 但是还没有解决对象注入的问题，下一节使用自动装配（@AutoWired）解对象注入问题。 自动装配-@AutoWired-下一节","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"SSM","slug":"框架/SSM","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/SSM/"},{"name":"Spring","slug":"框架/SSM/Spring","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/SSM/Spring/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"SSM","slug":"框架/SSM","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/SSM/"},{"name":"Spring","slug":"框架/SSM/Spring","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/SSM/Spring/"}]},{"title":"Mybatis中的3种级联方式","slug":"Mybatis中的3种级联方式","date":"2020-05-01T15:50:16.000Z","updated":"2020-05-01T16:09:24.789Z","comments":true,"path":"2020/05/01/Mybatis中的3种级联方式/","link":"","permalink":"http://yoursite.com/2020/05/01/Mybatis%E4%B8%AD%E7%9A%843%E7%A7%8D%E7%BA%A7%E8%81%94%E6%96%B9%E5%BC%8F/","excerpt":"","text":"Mybatis中的级联 Mybatis的3种级联 鉴别器（discriminator）： 他是一个根据某些条件决定采用具体实现类的级联的方案，比如体检要根据性别区分。 一对一（association）： 比如你的省份证和你就是一种一对一的级联。 一对多（collection）： 比如班主任和学生就是一种一对多的级联。 值得注意的是，Mybatis中没有多对多的级联，因为多对多级联比较复杂。使用困难，而且可以通过两个一对多级联进行替换，所以Mybatis不支持多对多级联。 示例 确定一个雇员级联模型 分析雇员级联模型 1. 该模型是以雇员表为中心的。 2. 雇员表和工牌表示 “一对一” 的级联关系。 3. 雇员表和员工任务表示 “ 一对多” 的级联关系。 4. 员工任务表和任务表是 “一对一” 的级联关系。 5. 每个员工都会有一个体检表，它是根据性别的不同，得到不同的关联表，所以是 “鉴别器” 的级联关系。 表的设计 SQL语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156DROP TABLE IF EXISTS t_female_health_form;DROP TABLE IF EXISTS t_male_health_form;DROP TABLE IF EXISTS t_task;DROP TABLE IF EXISTS t_work_card;DROP TABLE IF EXISTS t_employee_task;DROP TABLE IF EXISTS t_employee;/*==============================================================*//* Table: t_employee 雇员表 *//*==============================================================*/CREATE TABLE t_employee( id INT(12) NOT NULL AUTO_INCREMENT, real_name VARCHAR(60) NOT NULL, sex INT(2) NOT NULL COMMENT '1 - 男 0 -女', birthday DATE NOT NULL, mobile VARCHAR(20) NOT NULL, email VARCHAR(60) NOT NULL, POSITION VARCHAR(20) NOT NULL, note VARCHAR(256), PRIMARY KEY (id));/*==============================================================*//* Table: t_employee_task 员工任务表 *//*==============================================================*/CREATE TABLE t_employee_task( id INT(12) NOT NULL auto_increment, emp_id INT(12) NOT NULL, task_id INT(12) NOT NULL, task_name VARCHAR(60) NOT NULL, note VARCHAR(256), PRIMARY KEY (id));/*==============================================================*//* Table: t_female_health_form 女性体检表 *//*==============================================================*/CREATE TABLE t_female_health_form( id INT(12) NOT NULL AUTO_INCREMENT, emp_id INT(12) NOT NULL, heart VARCHAR(64) NOT NULL, liver VARCHAR(64) NOT NULL, spleen VARCHAR(64) NOT NULL, lung VARCHAR(64) NOT NULL, kidney VARCHAR(64) NOT NULL, uterus VARCHAR(64) NOT NULL, note VARCHAR(256), PRIMARY KEY (id));/*==============================================================*//* Table: t_male_health_form 男性体检表 *//*==============================================================*/CREATE TABLE t_male_health_form( id INT(12) NOT NULL AUTO_INCREMENT, emp_id INT(12) NOT NULL, heart VARCHAR(64) NOT NULL, liver VARCHAR(64) NOT NULL, spleen VARCHAR(64) NOT NULL, lung VARCHAR(64) NOT NULL, kidney VARCHAR(64) NOT NULL, prostate VARCHAR(64) NOT NULL, note VARCHAR(256), PRIMARY KEY (id));/*==============================================================*//* Table: t_task 任务表 *//*==============================================================*/CREATE TABLE t_task( id INT(12) NOT NULL auto_increment, title VARCHAR(60) NOT NULL, context VARCHAR(256) NOT NULL, note VARCHAR(256), PRIMARY KEY (id));/*==============================================================*//* Table: t_work_card 工牌表 *//*==============================================================*/CREATE TABLE t_work_card( id INT(12) NOT NULL AUTO_INCREMENT, emp_id INT(12) NOT NULL, real_name VARCHAR(60) NOT NULL, department VARCHAR(20) NOT NULL, mobile VARCHAR(20) NOT NULL, POSITION VARCHAR(30) NOT NULL, note VARCHAR(256), PRIMARY KEY (id));/*==============================================================*//* 外键约束 *//*==============================================================*/ALTER TABLE t_employee_task ADD CONSTRAINT FK_Reference_4 FOREIGN KEY (emp_id) REFERENCES t_employee (id) ON DELETE RESTRICT ON UPDATE RESTRICT;ALTER TABLE t_employee_task ADD CONSTRAINT FK_Reference_8 FOREIGN KEY (task_id) REFERENCES t_task (id) ON DELETE RESTRICT ON UPDATE RESTRICT;ALTER TABLE t_female_health_form ADD CONSTRAINT FK_Reference_5 FOREIGN KEY (emp_id) REFERENCES t_employee (id) ON DELETE RESTRICT ON UPDATE RESTRICT;ALTER TABLE t_male_health_form ADD CONSTRAINT FK_Reference_6 FOREIGN KEY (emp_id) REFERENCES t_employee (id) ON DELETE RESTRICT ON UPDATE RESTRICT;ALTER TABLE t_work_card ADD CONSTRAINT FK_Reference_7 FOREIGN KEY (emp_id) REFERENCES t_employee (id) ON DELETE RESTRICT ON UPDATE RESTRICT;/*==============================================================*//* 插入测试数据 *//*==============================================================*//*雇员表*/INSERT INTO t_employee(id,real_name,sex,birthday,mobile,email,POSITION,note) VALUES (DEFAULT,'employee_1',1,'2000-04-23','18773459883','employee_1@.com','Programmer','小刘');INSERT INTO t_employee(id,real_name,sex,birthday,mobile,email,POSITION,note) VALUES (DEFAULT,'employee_2',1,'2000-01-03','18773324883','employee_2@.com','Programmer','小王');INSERT INTO t_employee(id,real_name,sex,birthday,mobile,email,POSITION,note) VALUES (DEFAULT,'employee_3',0,'2000-02-20','18773443555','employee_3@.com','Programmer','小徐');INSERT INTO t_employee(id,real_name,sex,birthday,mobile,email,POSITION,note) VALUES (DEFAULT,'employee_4',0,'2000-04-29','18773464467','employee_4@.com','Programmer','小陆');/*男性体检表*/INSERT INTO t_male_health_form(id,emp_id,heart,liver,spleen,lung,kidney,prostate,note) VALUES(DEFAULT,1,'normal','normal','normal','normal','normal','normal','***医院');INSERT INTO t_male_health_form(id,emp_id,heart,liver,spleen,lung,kidney,prostate,note) VALUES(DEFAULT,2,'normal','normal','normal','normal','normal','normal','***医院');/*女性体检表*/INSERT INTO t_female_health_form(id,emp_id,heart,liver,spleen,lung,kidney,uterus,note) VALUES(DEFAULT,3,'normal','normal','normal','normal','normal','normal','***医院');INSERT INTO t_female_health_form(id,emp_id,heart,liver,spleen,lung,kidney,uterus,note) VALUES(DEFAULT,4,'normal','normal','normal','normal','normal','normal','***医院');/*工牌表*/INSERT INTO t_work_card(id,emp_id,real_name,department,mobile,POSITION,note) VALUES (DEFAULT,1,'employee_1','Tech-Dept','employee_1@.com','Programmer','小刘');INSERT INTO t_work_card(id,emp_id,real_name,department,mobile,POSITION,note) VALUES (DEFAULT,2,'employee_2','Tech-Dept','employee_2@.com','Programmer','小王');INSERT INTO t_work_card(id,emp_id,real_name,department,mobile,POSITION,note) VALUES (DEFAULT,3,'employee_3','Tech-Dept','employee_3@.com','Programmer','小徐');INSERT INTO t_work_card(id,emp_id,real_name,department,mobile,POSITION,note) VALUES (DEFAULT,4,'employee_4','Tech-Dept','employee_4@.com','Programmer','小陆');/*任务表*/INSERT INTO t_task(id,title,context,note) VALUE(DEFAULT,'前端','HTML+CSS+JS+JQuery+Bootstrap+Ajax','前端开发');INSERT INTO t_task(id,title,context,note) VALUE(DEFAULT,'后端','Spring+SpringMVC+Mybatis+Redis','后端开发');/*员工任务表*/INSERT INTO t_employee_task(id,emp_id,task_id,task_name,note) VALUES(DEFAULT,1,2,'后端开发','后端');INSERT INTO t_employee_task(id,emp_id,task_id,task_name,note) VALUES(DEFAULT,2,2,'后端开发','后端');INSERT INTO t_employee_task(id,emp_id,task_id,task_name,note) VALUES(DEFAULT,3,1,'前端开发','前端');INSERT INTO t_employee_task(id,emp_id,task_id,task_name,note) VALUES(DEFAULT,4,1,'前端开发','前端'); 示例项目主体结构 示例代码 建立POJO 建立POJO之前先建立一个性别枚举类和一个自定义TypeHandler类 1. SexEnum.java 1234567891011121314151617181920212223242526272829303132333435363738394041package com.ssm.enumeration;/** * 性别枚举 */public enum SexEnum &#123; MALE(1,\"男\"), FEMALE(0,\"女\"); private int id; private String name; public void setId(int id) &#123; this.id = id; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125; public String getName() &#123; return name; &#125; SexEnum(int id, String name) &#123; this.id = id; this.name = name; &#125; public static SexEnum getSexById(int id)&#123; for (SexEnum sex : SexEnum.values())&#123; if (sex.getId() == id)&#123; return sex; &#125; &#125; return null; &#125;&#125; SexTypeHandler.java 1234567891011121314151617181920212223242526272829303132333435package com.ssm.typeHandler;import com.ssm.enumeration.SexEnum;import org.apache.ibatis.type.BaseTypeHandler;import org.apache.ibatis.type.JdbcType;import java.sql.CallableStatement;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class SexTypeHandler extends BaseTypeHandler&lt;SexEnum&gt; &#123; @Override public SexEnum getNullableResult(ResultSet rs, String name) throws SQLException &#123; int sex = rs.getInt(name); return SexEnum.getSexById(sex); &#125; @Override public SexEnum getNullableResult(ResultSet rs, int index) throws SQLException &#123; int sex = rs.getInt(index); return SexEnum.getSexById(sex); &#125; @Override public SexEnum getNullableResult(CallableStatement cs, int index) throws SQLException &#123; int sex = cs.getInt(index); return SexEnum.getSexById(sex); &#125; @Override public void setNonNullParameter(PreparedStatement ps, int index, SexEnum sex, JdbcType jdbcType) throws SQLException &#123; ps.setInt(index, sex.getId()); &#125;&#125; 主要实体类 HealthFoem.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.ssm.pojo;/** * 体检实体类 */public class HealthForm &#123; private Long id; private Long empId; private String heart; private String liver; private String spleen; private String lung; private String kidney; private String note; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public Long getEmpId() &#123; return empId; &#125; public void setEmpId(Long empId) &#123; this.empId = empId; &#125; public String getHeart() &#123; return heart; &#125; public void setHeart(String heart) &#123; this.heart = heart; &#125; public String getLiver() &#123; return liver; &#125; public void setLiver(String liver) &#123; this.liver = liver; &#125; public String getSpleen() &#123; return spleen; &#125; public void setSpleen(String spleen) &#123; this.spleen = spleen; &#125; public String getLung() &#123; return lung; &#125; public void setLung(String lung) &#123; this.lung = lung; &#125; public String getKidney() &#123; return kidney; &#125; public void setKidney(String kidney) &#123; this.kidney = kidney; &#125; public String getNote() &#123; return note; &#125; public void setNote(String note) &#123; this.note = note; &#125; @Override public String toString() &#123; return \"HealthForm&#123;\" + \"id=\" + id + \", empId=\" + empId + \", heart='\" + heart + '\\'' + \", liver='\" + liver + '\\'' + \", spleen='\" + spleen + '\\'' + \", lung='\" + lung + '\\'' + \", kidney='\" + kidney + '\\'' + \", note='\" + note + '\\'' + '&#125;'; &#125;&#125; MaleHealthForm.java 1234567891011121314151617package com.ssm.pojo;/** * 男性体检实体类 */public class MaleHealthForm extends HealthForm &#123; private String prostate; public String getProstate() &#123; return prostate; &#125; public void setProstate(String prostate) &#123; this.prostate = prostate; &#125;&#125; FemaleHealthForm.java 1234567891011121314151617package com.ssm.pojo;/** * 女性体检实体类 */public class FemaleHealthForm extends HealthForm &#123; private String uterus; public String getUterus() &#123; return uterus; &#125; public void setUterus(String uterus) &#123; this.uterus = uterus; &#125;&#125; WorkCard.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.ssm.pojo;/** * 工牌卡实体类 */public class WorkCard &#123; private Long id; private Long empId; private String realName; private String department; private String mobile; private String position; private String note; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public Long getEmpId() &#123; return empId; &#125; public void setEmpId(Long empId) &#123; this.empId = empId; &#125; public String getRealName() &#123; return realName; &#125; public void setRealName(String realName) &#123; this.realName = realName; &#125; public String getDepartment() &#123; return department; &#125; public void setDepartment(String department) &#123; this.department = department; &#125; public String getMobile() &#123; return mobile; &#125; public void setMobile(String mobile) &#123; this.mobile = mobile; &#125; public String getPosition() &#123; return position; &#125; public void setPosition(String position) &#123; this.position = position; &#125; public String getNote() &#123; return note; &#125; public void setNote(String note) &#123; this.note = note; &#125; @Override public String toString() &#123; return \"WorkCard&#123;\" + \"id=\" + id + \", empId=\" + empId + \", realName='\" + realName + '\\'' + \", department='\" + department + '\\'' + \", mobile='\" + mobile + '\\'' + \", position='\" + position + '\\'' + \", note='\" + note + '\\'' + '&#125;'; &#125;&#125; Task.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.ssm.pojo;/** * 任务实体类 */public class Task &#123; private Long id; private String title; private String context; private String note; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContext() &#123; return context; &#125; public void setContext(String context) &#123; this.context = context; &#125; public String getNote() &#123; return note; &#125; public void setNote(String note) &#123; this.note = note; &#125; @Override public String toString() &#123; return \"Task&#123;\" + \"id=\" + id + \", title='\" + title + '\\'' + \", context='\" + context + '\\'' + \", note='\" + note + '\\'' + '&#125;'; &#125;&#125; EmployeeTask.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.ssm.pojo;/** * 雇员任务实体类 */public class EmployeeTask &#123; private Long id; private Long empId; private Task task = null; private String taskName; private String note; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public Long getEmpId() &#123; return empId; &#125; public void setEmpId(Long empId) &#123; this.empId = empId; &#125; public Task getTask() &#123; return task; &#125; public void setTask(Task task) &#123; this.task = task; &#125; public String getTaskName() &#123; return taskName; &#125; public void setTaskName(String taskName) &#123; this.taskName = taskName; &#125; public String getNote() &#123; return note; &#125; public void setNote(String note) &#123; this.note = note; &#125; @Override public String toString() &#123; return \"EmployeeTask&#123;\" + \"id=\" + id + \", empId=\" + empId + \", task=\" + task + \", taskName='\" + taskName + '\\'' + \", note='\" + note + '\\'' + '&#125;'; &#125;&#125; Employee.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.ssm.pojo;import java.util.Date;import java.util.List;import com.ssm.enumeration.SexEnum;/** * 雇员实体类 */public class Employee &#123; private Long id; private String realName; private SexEnum sex = null; private Date birthday; private String mobile; private String email; private String position; private String note; //工牌按一对一级联 private WorkCard workCard; //雇员任务，一对多级联 private List&lt;EmployeeTask&gt; employeeTaskList = null; public Long getId() &#123; return id; &#125; public void setId(Long id) &#123; this.id = id; &#125; public String getRealName() &#123; return realName; &#125; public void setRealName(String realName) &#123; this.realName = realName; &#125; public SexEnum getSex() &#123; return sex; &#125; public void setSex(SexEnum sex) &#123; this.sex = sex; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getMobile() &#123; return mobile; &#125; public void setMobile(String mobile) &#123; this.mobile = mobile; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public String getPosition() &#123; return position; &#125; public void setPosition(String position) &#123; this.position = position; &#125; public String getNote() &#123; return note; &#125; public void setNote(String note) &#123; this.note = note; &#125; public WorkCard getWorkCard() &#123; return workCard; &#125; public void setWorkCard(WorkCard workCard) &#123; this.workCard = workCard; &#125; public List&lt;EmployeeTask&gt; getEmployeeTaskList() &#123; return employeeTaskList; &#125; public void setEmployeeTaskList(List&lt;EmployeeTask&gt; employeeTaskList) &#123; this.employeeTaskList = employeeTaskList; &#125; @Override public String toString() &#123; return \"Employee&#123;\" + \"id=\" + id + \", realName='\" + realName + '\\'' + \", sex=\" + sex + \", birthday=\" + birthday + \", mobile='\" + mobile + '\\'' + \", email='\" + email + '\\'' + \", position='\" + position + '\\'' + \", note='\" + note + '\\'' + \", workCard=\" + workCard + \", employeeTaskList=\" + employeeTaskList + '&#125;'; &#125;&#125; MaleEmployee.java 123456789101112131415161718package com.ssm.pojo;/** * 男雇员实体类 */public class MaleEmployee extends Employee &#123; private MaleHealthForm maleHealthForm = null; public MaleHealthForm getMaleHealthForm() &#123; return maleHealthForm; &#125; public void setMaleHealthForm(MaleHealthForm maleHealthForm) &#123; this.maleHealthForm = maleHealthForm; &#125;&#125; FemaleEmployee.java 123456789101112131415161718package com.ssm.pojo;/** * 女雇员实体类 */public class FemaleEmployee extends Employee &#123; private FemaleHealthForm femaleHealthForm = null; public FemaleHealthForm getFemaleHealthForm() &#123; return femaleHealthForm; &#125; public void setFemaleHealthForm(FemaleHealthForm femaleHealthForm) &#123; this.femaleHealthForm = femaleHealthForm; &#125;&#125; 配置映射文件Mapper * 数据库文件和日志文件 jdbc.properties 1234database.driver=com.mysql.jdbc.Driverdatabase.url=jdbc:mysql://localhost:3306/employeedatabase.username=rootdatabase.password=123456 log4j.properties 12345log4j.rootLogger=DEBUG , stdoutlog4j.logger.org.mybatis=DEBUGlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p %d %C: %m%n mybatis_config.xml 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;properties resource=\"jdbc.properties\" /&gt; &lt;typeAliases&gt; &lt;package name=\"com.ssm.pojo\"/&gt; &lt;/typeAliases&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;database.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;database.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;database.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;database.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name=\"com.ssm.mapper\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 实体类映射文件和接口 TaskMapper.java 123456789package com.ssm.mapper;import com.ssm.pojo.Task;import java.util.List;public interface TaskMapper &#123; public Task selTask(Long id);&#125; TaskMapper.xml 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ssm.mapper.TaskMapper\"&gt; &lt;select id=\"selTask\" parameterType=\"long\" resultType=\"task\"&gt; select id,title,context,note from t_task where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; WorkCardMapper.java 123456789package com.ssm.mapper;import com.ssm.pojo.WorkCard;import java.util.List;public interface WorkCardMapper &#123; public WorkCard selWorkCardByEmpId(Long empid);&#125; WorkCardMapper.xml 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ssm.mapper.WorkCardMapper\"&gt; &lt;select id=\"selWorkCardByEmpId\" parameterType=\"long\" resultType=\"workCard\"&gt; select id,emp_id as empid,real_name as realName,department,mobile,position,note from t_work_card where emp_id = #&#123;empid&#125; &lt;/select&gt;&lt;/mapper&gt; EmployeeTaskMapper.java 123456789package com.ssm.mapper;import com.ssm.pojo.EmployeeTask;import java.util.List;public interface EmployeeTaskMapper &#123; public EmployeeTask selEmployeeTaskByEmpId(Long empId);&#125; EmployeeTaskMapper.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ssm.mapper.EmployeeTaskMapper\"&gt; &lt;resultMap id=\"EmployeeTaskMap\" type=\"com.ssm.pojo.EmployeeTask\"&gt; &lt;id property=\"empId\" column=\"emp_id\"&gt;&lt;/id&gt; &lt;result property=\"taskName\" column=\"task_name\"&gt;&lt;/result&gt; &lt;result property=\"note\" column=\"note\"&gt;&lt;/result&gt; &lt;!--雇员任务表一对一级联--&gt; &lt;association property=\"task\" column=\"task_id\" select=\"com.ssm.mapper.TaskMapper.selTask\"/&gt; &lt;/resultMap&gt; &lt;select id=\"selEmployeeTaskByEmpId\" parameterType=\"long\" resultMap=\"EmployeeTaskMap\"&gt; select id,emp_id,task_name,note,task_id from t_employee_task where emp_id = #&#123;empId&#125; &lt;/select&gt;&lt;/mapper&gt; MaleHealthFormMapper.java 123456789package com.ssm.mapper;import com.ssm.pojo.MaleHealthForm;import java.util.List;public interface MaleHealthFormMapper &#123; public MaleHealthForm selMaleHealthForm(Long id);&#125; MaleHealthFormMapper.xml 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ssm.mapper.MaleHealthFormMapper\"&gt; &lt;select id=\"selMaleHealthForm\" parameterType=\"long\" resultType=\"maleHealthForm\"&gt; select id,emp_id as empId,heart,liver,spleen,lung,kidney,prostate,note from t_male_health_form where emp_id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; FemaleHealthFormMapper.java 12345678package com.ssm.mapper;import com.ssm.pojo.FemaleHealthForm;public interface FemaleHealthFormMapper &#123; public FemaleHealthForm selFemaleHealthForm(Long id);&#125; FemaleHealthFormMapper.xml 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ssm.mapper.FemaleHealthFormMapper\"&gt; &lt;select id=\"selFemaleHealthForm\" parameterType=\"long\" resultType=\"femaleHealthForm\"&gt; select id,emp_id as empId,heart,liver,spleen,lung,kidney,uterus,note from t_female_health_form where emp_id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; EmployeeMapper.java 12345678package com.ssm.mapper;import com.ssm.pojo.Employee;public interface EmployeeMapper &#123; public Employee selEmployee(Long id);&#125; EmployeeMapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ssm.mapper.EmployeeMapper\"&gt; &lt;resultMap id=\"employee\" type=\"com.ssm.pojo.Employee\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"realName\" column=\"real_name\"/&gt; &lt;result property=\"sex\" column=\"sex\" typeHandler=\"com.ssm.typeHandler.SexTypeHandler\"/&gt; &lt;result property=\"birthday\" column=\"birthday\"/&gt; &lt;result property=\"mobile\" column=\"mobile\"/&gt; &lt;result property=\"email\" column=\"email\"/&gt; &lt;result property=\"position\" column=\"position\"/&gt; &lt;result property=\"note\" column=\"note\"/&gt; &lt;!--工牌表一对一级联--&gt; &lt;association property=\"workCard\" column=\"id\" select=\"com.ssm.mapper.WorkCardMapper.selWorkCardByEmpId\"/&gt; &lt;!--雇员任务，一对多级联--&gt; &lt;collection property=\"employeeTaskList\" column=\"id\" select=\"com.ssm.mapper.EmployeeTaskMapper.selEmployeeTaskByEmpId\"/&gt; &lt;!--鉴别器--&gt; &lt;discriminator javaType=\"long\" column=\"sex\"&gt; &lt;case value=\"1\" resultMap=\"maleHealthFormMapper\"/&gt; &lt;case value=\"0\" resultMap=\"femaleHealthFormMapper\"/&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; &lt;resultMap id=\"maleHealthFormMapper\" type=\"com.ssm.pojo.MaleEmployee\" extends=\"employee\"&gt; &lt;association property=\"maleHealthForm\" column=\"id\" select=\"com.ssm.mapper.MaleHealthFormMapper.selMaleHealthForm\"/&gt; &lt;/resultMap&gt; &lt;resultMap id=\"femaleHealthFormMapper\" type=\"com.ssm.pojo.FemaleEmployee\" extends=\"employee\"&gt; &lt;association property=\"femaleHealthForm\" column=\"id\" select=\"com.ssm.mapper.FemaleHealthFormMapper.selFemaleHealthForm\"/&gt; &lt;/resultMap&gt; &lt;select id=\"selEmployee\" parameterType=\"long\" resultMap=\"employee\"&gt; select id, real_name as realName, sex, birthday, mobile, email, position,note from t_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 测试类 EmployeeTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.ssm.test;import com.ssm.mapper.EmployeeMapper;import com.ssm.mapper.FemaleHealthFormMapper;import com.ssm.mapper.MaleHealthFormMapper;import com.ssm.pojo.*;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.apache.log4j.Logger;import java.io.InputStream;public class EmployeeTest &#123; public static void main(String[] args) &#123; selEmployee(); &#125; public static void selEmployee()&#123; SqlSession session = null; Logger logger = Logger.getLogger(EmployeeTask.class); try&#123; InputStream is = Resources.getResourceAsStream(\"mybatis-config.xml\"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is); session = factory.openSession(); EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class); Employee employee = employeeMapper.selEmployee(3L); System.out.println(\"员工基本信息：\"+employee.toString()); if ((employee.getSex().toString()).equals(\"MALE\"))&#123; MaleHealthFormMapper maleHealthFormMapper = session.getMapper(MaleHealthFormMapper.class); MaleHealthForm maleHealthForm = maleHealthFormMapper.selMaleHealthForm(employee.getId()); System.out.println(\"员工体检：\"+maleHealthForm.toString()); &#125;else if ((employee.getSex().toString()).equals(\"FEMALE\"))&#123; FemaleHealthFormMapper femaleHealthFormMapper = session.getMapper(FemaleHealthFormMapper.class); FemaleHealthForm femaleHealthForm = femaleHealthFormMapper.selFemaleHealthForm(employee.getId()); System.out.println(\"员工体检：\"+femaleHealthForm.toString()); &#125; session.commit(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; if(session != null)&#123; session.close(); &#125; &#125; &#125;&#125; 测试结果 12员工基本信息：Employee&#123;id=3, realName='employee_3', sex=FEMALE, birthday=Sun Feb 20 00:00:00 CST 2000, mobile='18773443555', email='employee_3@.com', position='Programmer', note='小徐', workCard=WorkCard&#123;id=3, empId=3, realName='employee_3', department='Tech-Dept', mobile='employee_3@.com', position='Programmer', note='小徐'&#125;, employeeTaskList=[EmployeeTask&#123;id=3, empId=3, task=Task&#123;id=1, title='前端', context='HTML+CSS+JS+JQuery+Bootstrap+Ajax', note='前端开发'&#125;, taskName='前端开发', note='前端'&#125;]&#125;员工体检：HealthForm&#123;id=1, empId=3, heart='normal', liver='normal', spleen='normal', lung='normal', kidney='normal', note='***医院'&#125; 注意 特别注意 EmployeeMapper.xml 的映射文件 association元素：对工牌进行一对一级联，其select元素指向SQL，将通过column的id作为参数进行传递，然后将结果返回给雇员POJO的属性workCard。 collection元素：一对多级联，其select元素指向SQL，将通过column的id作为参数进行传递，然后将结果返回给雇员POJO的属性employeeTaskList。 discrimination元素：鉴别器，它的属性column的值代表使用哪个字段进行鉴别，这里的是sex，而它的子元素case，则用于进行区分，类似于java中的switch…case…语句。而resultMap属性表示采用哪个ResultMap去映射，比如sex=1，则使用maleHealthFormMap进行映射。","categories":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"SSM","slug":"框架/SSM","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/SSM/"},{"name":"Mybatis","slug":"框架/SSM/Mybatis","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/SSM/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"},{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"}],"keywords":[{"name":"框架","slug":"框架","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/"},{"name":"SSM","slug":"框架/SSM","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/SSM/"},{"name":"Mybatis","slug":"框架/SSM/Mybatis","permalink":"http://yoursite.com/categories/%E6%A1%86%E6%9E%B6/SSM/Mybatis/"}]},{"title":"Linux文件与目录结构","slug":"Linux文件与目录结构","date":"2020-05-01T15:40:06.000Z","updated":"2020-05-01T15:40:49.200Z","comments":true,"path":"2020/05/01/Linux文件与目录结构/","link":"","permalink":"http://yoursite.com/2020/05/01/Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/","excerpt":"","text":"Linux文件与目录结构 Linux文件 Linux系统中一切皆文件。 Linux目录结构 1.安装tree命令 系统中默认没有tree这个命令的，需要安装 安装命令： 1yum install tree Ubuntu系统安装命令： 1sudo apt-get install tree 2.tree命令 输入命令： 1tree --help 查看命令使用方式： 3.使用命令tree查看 1.使用cd /进入&quot;/“目录 输入tree命令 将会显示”/&quot;下所有的目录和文件（文件太多了 不好截图） 2.使用 1tree -L 数字 显示你想要的目录层次结构 例如：tree -L 1 1tree -L 2 或者使用ls /命令查看： OK 进入正题 Linux的目录结构 树状结构： Linux目录结构简介 在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。 /etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。 /bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。 值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。 /var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里。 这里介绍的更加详细–&gt;&gt;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}]},{"title":"vi和vim的基本介绍","slug":"vi和vim的基本介绍","date":"2020-05-01T15:27:06.000Z","updated":"2020-05-01T15:33:05.571Z","comments":true,"path":"2020/05/01/vi和vim的基本介绍/","link":"","permalink":"http://yoursite.com/2020/05/01/vi%E5%92%8Cvim%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"vi和vim的基本介绍 是什么 VI 是Unix操作系统和类Unix操作系统中最通用的文本编译器。 VIM 编译器是从VI 编译器发展出来一个性能更强大的文本编译器，可以主动的以字体颜色辨别语法的正确性，方便程序设计。 Vim的安装 centos系统： 普通用户下输入命令：yum -y install vim* ubuntu系统： 普通用户下输入命令：sudo apt-get install vim-gtk 之后输入y，即可等待安装完成。 输入： 1[root@localhost ~]# vim 显示 安装成功！！ VIM Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 vim键盘图： VI/Vim常用的三种模式 基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），编辑模式（Edit mode）和指令模式（Instruction mode）。 这三种模式的作用分别是： 命令模式： 以 VI/Vim 打开一个文件就直接进入一般模式 了（默认的模式），在该模式中可以使用『上下左右』按键来移动光标，也可以使用『删除字符（x/X)』和『删除整行（dd）』处理文本内容，同样也可以『复制（yy）』『粘贴（p）』『撤销上一步（u）』来处理你的文件数据。 在命令模式中，输入『 : / ?』3个中的任何一个按钮，就可以将光标移动到最底下那一行。 语法 功能描述 yy 复制光标当前一行 y数字y 复制一段（从第几行到第几行） p 箭头移动到目的行粘贴 u 撤销上一步 dd 删除光标当前行 d数字d 删除光标（含）后多少行 x 删除一个字母，相当于del，向后删 X 删除一个字母，相当于Backspace，向前删 yw 复制一个词 dw 删除一个词 shift+^ 移动到行头 shift+$ 移动到行尾 gg或者1+G 移动到页头 G 移动到页尾 数字+G （先输入数字，在按G） 移动到目标行 编辑模式： 在一般模式中可以进行删除、复制、粘贴等的动作，但是无法编辑文件内容！要等到你按下『i, I, o, O, a, A, r, R』等任何一个字母之后才会进入编辑模式。 注意了！通常在Linux中，按下这些按键时，在画面的左下方会出现『INSERT或 REPLACE』的字样，此时才可以进行编辑。而如果要回到一般模式时， 则必须要按下『Esc』这个按键即可退出编辑模式。 进入编辑模式： 按键 功能 i 当前光标前 a 当前光标后 o 当前光标行的下一行 I 光标所在行最前 A 光标所在行最后 O 当前光标行的上一行 退出编辑模式： 按『Esc』键 指令模式： 在这个模式当中， 可以提供你『搜寻资料』的动作，而读取、存盘、大量取代字符、离开 vi 、显示行号等动作是在此模式中达成的！ 命令 功能 :w 保存文件 :q 退出执行 :! 强制执行 / 要查找的词 n 查找下一个，N 往上查找 ? 要查找的词 n是查找上一个，N是往下查找 :set nu 显示行号 :set nonu 关闭行号 ZZ（shift+zz） 没有修改文件直接退出，如果修改了文件保存后退出 强制保存并退出： ：wq! 模式之间的转换","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"编辑器","slug":"Linux/编辑器","permalink":"http://yoursite.com/categories/Linux/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"Vim","slug":"Linux/编辑器/Vim","permalink":"http://yoursite.com/categories/Linux/%E7%BC%96%E8%BE%91%E5%99%A8/Vim/"}],"tags":[{"name":"Liunx","slug":"Liunx","permalink":"http://yoursite.com/tags/Liunx/"},{"name":"编辑器","slug":"编辑器","permalink":"http://yoursite.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"Vim","slug":"Vim","permalink":"http://yoursite.com/tags/Vim/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"编辑器","slug":"Linux/编辑器","permalink":"http://yoursite.com/categories/Linux/%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"Vim","slug":"Linux/编辑器/Vim","permalink":"http://yoursite.com/categories/Linux/%E7%BC%96%E8%BE%91%E5%99%A8/Vim/"}]},{"title":"虚拟机克隆","slug":"虚拟机克隆","date":"2020-05-01T15:20:24.000Z","updated":"2020-05-01T15:24:37.062Z","comments":true,"path":"2020/05/01/虚拟机克隆/","link":"","permalink":"http://yoursite.com/2020/05/01/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%8B%E9%9A%86/","excerpt":"","text":"虚拟机克隆 1.关闭要被克隆的虚拟机 12[root@localhost ~]# sync[root@localhost ~]# shutdown -h now 2.右击找到克隆选项 3.欢迎界面 4.选择当前状态 5.注意选择创建完整克隆(F) 6.命名虚拟机名称/自定义目录 7.正在克隆 8.创建成功/点击关闭 9.修改克隆后虚拟机的IP 1[root@localhost ~]# vim /etc/udev/rules.d/70-persistent-net.rules 进入如下界面，删除eth0行（删除整行命令：d）； 将eth1修改为eth0.同时复制物理IP地址，如下图所示： 查看是否修改成功： 1[root@localhost ~]# cat /etc/udev/rules.d/70-persistent-net.rules 修改成功！ 10.修改 IP 地址 1[root@localhost ~]# vim /etc/sysconfig/network-scripts/ifcfg-eth0 （1）把复制的物理ip地址更新 HWADDR=00:0c:29:4e:cf:72 #MAC地址 （2）修改成你想要的ip IPADDR=192.168.26.131 #IP地址 11.修改主机名称（可不修改） （1）查看当前服务器主机名称： 1[root@localhost ~]# hostname （2）如果感觉此主机名不合适，我们可以进行修改。通过编辑/etc/sysconfig/network文件 1[root@localhost ~]# vim /etc/sysconfig/network 注意：主机名称不要有“_”下划线 （3）打开此文件后，可以看到主机名。 （4）保存退出。 12.重新启动服务器 1[root@localhost etc]# service network restart 重启成功 重启失败 错误：激活连接失败：The connection is not for this device. 如果报错，reboot，重启虚拟机","categories":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://yoursite.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"keywords":[{"name":"虚拟机","slug":"虚拟机","permalink":"http://yoursite.com/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"Ubuntu--配置静态IP","slug":"Ubuntu-配置静态IP","date":"2020-05-01T15:16:52.000Z","updated":"2020-05-01T15:18:28.060Z","comments":true,"path":"2020/05/01/Ubuntu-配置静态IP/","link":"","permalink":"http://yoursite.com/2020/05/01/Ubuntu-%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/","excerpt":"","text":"Ubuntu–配置静态IP 1.进入root 1coffeecode@hadoop135:~$ su - 输入密码–进入root用户 2.先停止Network-manager的服务 1sudo service network-manager stop 3.修改/etc/network/interfaces配置文件 1sudo vi &#x2F;etc&#x2F;network&#x2F;interfaces 在文件中加入下面内容： 12345678910auto ens33iface ens33 inet static# IP地址--根据你自己定义address 192.168.26.135# 子网掩码netmask 255.255.255.0# 网关gateway 192.168.26.2# DNS--和网关一样dns-nameservers 192.168.26.2 怎么查看该虚拟机的网关 1.编辑–虚拟网络编辑器（N） 2.打开NAT设置 3.查看网关 4.修改完成 5. 重启网络： 1&#x2F;etc&#x2F;init.d&#x2F;networking restart 重启网络失败： 重启系统： 1reboot 6.测试配置是否成功 查看cat /etc/resolv.conf文件中是否已经添加DNS 7.测试网络连接情况 1ifconfig 1ping www.baidu.com 配置成功！","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"网络配置","slug":"Linux/网络配置","permalink":"http://yoursite.com/categories/Linux/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"网络配置","slug":"网络配置","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"网络配置","slug":"Linux/网络配置","permalink":"http://yoursite.com/categories/Linux/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"}]},{"title":"Rational Rose Enterprise","slug":"Rational-Rose-Enterprise","date":"2020-05-01T15:09:44.000Z","updated":"2020-05-01T15:11:39.236Z","comments":true,"path":"2020/05/01/Rational-Rose-Enterprise/","link":"","permalink":"http://yoursite.com/2020/05/01/Rational-Rose-Enterprise/","excerpt":"","text":"下载Rational Rose Enterprise 下载链接: https://pan.baidu.com/s/152l2OMioSsh7QqcIXVI7Lg 提取码: pkj1 复制这段内容后打开百度网盘手机App，操作更方便哦 安装 1. 解压压缩包 2. 找到解压文件 双击EXE文件进行安装 3. 选择安装程序对应的系统 我这里是windows系统 4. 点击 next 进行安装 5. 点击 下一步 6. 选择安装类型 RationalRoseEnterpriseEdition 是ROSE编辑器 7. 选择第二个 8. 点击 next -&gt; next 9. 选择 I accept 10. next - &gt; next 默认第一个： 11. Install 12. 点击第二个 Import a Rational License File 14. 选择目录 找到： Rational Rose Enterprise 8.5.0506\\Crack\\license.upd文件 import： import： 15. 激活成功 发现激活有点问题：激活截止日期为 06-jan-2020 16. 确认是否激活 双击 激活失败： 解决办法 ---- 修改系统时间 右击任务栏时间部位 修改日期 激活成功 双击 激活成功","categories":[{"name":"项目工具","slug":"项目工具","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"}],"keywords":[{"name":"项目工具","slug":"项目工具","permalink":"http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7/"}]},{"title":"Shell编程","slug":"Shell编程","date":"2020-05-01T10:20:37.000Z","updated":"2020-05-08T03:25:59.167Z","comments":true,"path":"2020/05/01/Shell编程/","link":"","permalink":"http://yoursite.com/2020/05/01/Shell%E7%BC%96%E7%A8%8B/","excerpt":"","text":"1. 统计根分区使用率使用if 12345678910111213#!/bin/bash#统计根分区使用率rate=$(df -h | grep sda1 | awk '&#123;print $5&#125;' | cut -d \"%\" -f1)if [ $rate -ge 80 ] #判断rate的值，如果大于等于80,则执行then程序 then echo \"使用率达到80%！！！\" #打印警告信息 else echo \"使用率：$rate.\"fi 2.使用多分支把输出内容分别输出1号文件和2号文件 12345678910111213#!/bin/bash#统计根分区使用率rate=$(df -h | grep sda1 | awk '&#123;print $5&#125;' | cut -d \"%\" -f1)if [ $rate -ge 80 ] #判断rate的值，如果大于等于80,则执行then程序 then echo \"使用率达到80%！！！\" &gt;&gt; caveat.txt #打印警告信息 else echo \"使用率：$rate.\" &gt;&gt; normal.txtfi 4.判断用户输入的是什么文件？ 123456789101112131415161718192021222324#!/bin/bash#判断文件类型read -p \"请你输入文件名：\" file#判断file变量是否为空if [ -z \"file\" ] then echo \"错误，请重新输入。\" exit 1#判断文件是否存在elif [ ! -e \"$file\" ] then echo \"没有找到该文件！\" exit 2elif [ -f \"$file\" ] then echo \"$file 是文件。\"elif [ -d \"$file\" ] then echo \"$file 是目录。\"else echo \"$file 是其他类型的文件。\"fi 5.全局命令 地址：/usr/local/bin/xcall.sh 12345678#!/bin/bashparams=$@i=141for (( i=141; i &lt;= 143 ; i = $i + 1 )) ; do echo ============= hadoop$i $params ============= ssh hadoop$i \"$params\"done 实例： 12345678[root@hadoop142 bin]# xcall.sh jps============= hadoop141 jps =============5388 Jps============= hadoop142 jps =============12996 Jps============= hadoop143 jps =============14881 JpsYou have new mail in /var/spool/mail/root 6.全局分发 地址：/opt/module/xrsync.sh 12345678910111213141516171819202122232425#!/bin/bash#1 获取输入参数个数，如果没有参数，直接退出pcount=$#if ((pcount==0)); thenecho no args;exit;fi#2 获取文件名称p1=$1fname=`basename $p1`echo fname=$fname#3 获取上级目录的对路径pdir=`cd -P $(dirname $p1); pwd`echo pdir=$pdir#4 获取当前用户名称user=`whoami`#5 循环for((host=141; host&lt;143; host++)); do echo ------------------- hadoop$host -------------- rsync -av $pdir/$fname $user@hadoop$host:$pdirdone 7.启动zookeeper 12345678910111213141516171819202122232425262728#!/bin/basharg=$#if((arg==0));thenecho no args;exit;ficase $1 in\"start\")&#123; for i in hadoop141 hadoop142 hadoop143 do ssh $i \"$ZOOKEEPER_HOME/bin/zkServer.sh start\" done&#125;;;\"stop\")&#123; for i in hadoop141 hadoop142 hadoop143 do ssh $i \"$ZOOKEEPER_HOME/bin/zkServer.sh stop\" done&#125;;;\"status\")&#123; for i in hadoop141 hadoop142 hadoop143 do ssh $i \"$ZOOKEEPER_HOME/bin/zkServer.sh status\" done&#125;;; esac","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"Shell脚本","slug":"Linux/Shell脚本","permalink":"http://yoursite.com/categories/Linux/Shell%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Shell脚本","slug":"Shell脚本","permalink":"http://yoursite.com/tags/Shell%E8%84%9A%E6%9C%AC/"}],"keywords":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"},{"name":"Shell脚本","slug":"Linux/Shell脚本","permalink":"http://yoursite.com/categories/Linux/Shell%E8%84%9A%E6%9C%AC/"}]},{"title":"Python3 标准数据类型","slug":"Python3 标准数据类型","date":"2020-05-01T07:58:31.774Z","updated":"2020-05-08T11:30:49.014Z","comments":true,"path":"2020/05/01/Python3 标准数据类型/","link":"","permalink":"http://yoursite.com/2020/05/01/Python3%20%E6%A0%87%E5%87%86%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"Python3 标准数据类型 五种标准数据类型： 数字 – Numbers 字符串 – String 列表 – List 元组 – Tuple 集合 – Sets 字典 – Dictionary 数字–Numbers 数字包括：整数、长整数、浮点数、复数外加Boolean（true、false）型。 整数（int）：1、2、3、4 … 长整数（ 2.2以前）：能够表示很长的整数，根据整数的长度分配大小。 — 长整型也可以使用小写 l，但是还是建议您使用大写 L，避免与数字 1 混淆。Python使用 L 来显示长整型。 浮点数（float）：1.23、3E-2 复数（complex）：1 + 2j、1.1 + 2.2j 123&gt;&gt;&gt; a, b, c, d = 20, 5.5, True, 4+3j&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))&lt;class 'int'&gt; &lt;class 'float'&gt; &lt;class 'bool'&gt; &lt;class 'complex'&gt; 数值运算： 1234567891011121314&gt;&gt;&gt; 5 + 4 # 加法9&gt;&gt;&gt; 4.3 - 2 # 减法2.3&gt;&gt;&gt; 3 * 7 # 乘法21&gt;&gt;&gt; 2 / 4 # 除法，得到一个浮点数0.5&gt;&gt;&gt; 2 // 4 # 除法，得到一个整数0&gt;&gt;&gt; 17 % 3 # 取余 2&gt;&gt;&gt; 2 ** 5 # 乘方32 注意： 1、Python 可以同时为多过变量赋值： a, b, c, d = 20, 5.5, True, 4+3j； 2、一个变量可以赋值指向不同的数据类型的对象； 3、数值的除法（/）总是返回一个浮点数，要获取整数的话需使用（//）操作符： 12&gt;&gt;&gt; 7//23 4、在混合计算时，Pyhton会把整型转换成为浮点数。 5、long 类型只存在于 Python2.X 版本中，在 2.2 以后的版本中，int 类型数据溢出后会自动转为long类型。在 Python3.X 版本中 long 类型被移除，使用 int 替代。 字符串–String python中单引号和双引号使用完全相同。 使用三引号(’’'或&quot;&quot;&quot;)可以指定一个多行字符串。 转义符 ‘’ 自然字符串， 通过在字符串前加r或R。 如 r&quot;this is a line with \\n&quot; 则\\n会显示，并不是换行。 python允许处理unicode字符串，加前缀u或U， 如 u&quot;this is an unicode string&quot;。 字符串是不可变的。 按字面意义级联字符串，如&quot;this &quot; &quot;is &quot; &quot;string&quot;会被自动转换为this is string。 Python中的字符串str用单引号(’ ')或双引号(&quot; &quot;)括起来，同时使用反斜杠()转义特殊字符。 123&gt;&gt;&gt; s = 'Yes,he doesn\\'t'&gt;&gt;&gt; print(s, type(s), len(s))Yes,he doesn't 14 如果你不想让反斜杠发生转义，可以在字符串前面添加一个r，表示原始字符串： 12345&gt;&gt;&gt; print('C:\\some\\name')C:\\someame&gt;&gt;&gt; print(r'C:\\some\\name')C:\\some\\name 另外，反斜杠可以作为续行符，表示下一行是上一行的延续。还可以使用&quot;&quot;&quot;…&quot;&quot;&quot;或者’’’…’’'跨越多行。 字符串可以使用 + 运算符串连接在一起，或者用 * 运算符重复： 12&gt;&gt;&gt; print('str'+'ing', 'my'*3)string mymymy Python中的字符串有两种索引方式，第一种是从左往右，从0开始依次增加；第二种是从右往左，从-1开始依次减少。 注意，没有单独的字符类型，一个字符就是长度为1的字符串。 12345&gt;&gt;&gt; word = 'Python'&gt;&gt;&gt; print(word[0], word[5])P n&gt;&gt;&gt; print(word[-1], word[-6])n P 还可以对字符串进行切片，获取一段子串。用冒号分隔两个索引，形式为变量**[头下标:尾下标]**。 截取的范围是左闭右开的，并且两个索引都可以省略： 123456789&gt;&gt;&gt; word = 'ilovepython'&gt;&gt;&gt; word[1:5]'love'&gt;&gt;&gt; word[:]'ilovepython'&gt;&gt;&gt; word[5:]'python'&gt;&gt;&gt; word[-10:-6]'love' 与C字符串不同的是，Python字符串不能被改变。向一个索引位置赋值，比如word[0] = 'm’会导致错误。 注意： 1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。 2、字符串可以用+运算符连接在一起，用*运算符重复。 3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。 4、Python中的字符串不能改变。 列表 – List List（列表） 是 Python 中使用最频繁的数据类型 列表是写在方括号之间、用逗号分隔开的元素列表。列表中元素的类型可以不相同： 123&gt;&gt;&gt; a = [\"hello\",2,5980,\"world\"]&gt;&gt;&gt; print(a)['hello', 2, 5980, 'world'] 和字符串一样，列表同样可以被索引和切片，列表被切片后返回一个包含所需元素的新列表。 12345678&gt;&gt;&gt; a = [\"hello\",2,5980,\"world\"]&gt;&gt;&gt; print(a)['hello', 2, 5980, 'world']&gt;&gt;&gt; print(a[3])world&gt;&gt;&gt; print(a[1:3])[2, 5980]&gt;&gt;&gt; 列表还支持串联操作，使用+操作符： 123&gt;&gt;&gt; a = [\"hello\",2,5980,\"world\"]&gt;&gt;&gt; a + [3,5,6,6,34,'fdsf']['hello', 2, 5980, 'world', 3, 5, 6, 6, 34, 'fdsf'] 与Python字符串不一样的是，列表中的元素是可以改变的： 12345678&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; a[0] = 9&gt;&gt;&gt; a[2:5] = [13, 14, 15]&gt;&gt;&gt; a[9, 2, 13, 14, 15, 6]&gt;&gt;&gt; a[2:5] = [] # 删除&gt;&gt;&gt; a[9, 2, 6] List内置了有很多方法，例如append()、pop()等等，这在后面会讲到。 注意： 1、List写在方括号之间，元素用逗号隔开。 2、和字符串一样，list可以被索引和切片。 3、List可以使用+操作符进行拼接。 4、List中的元素是可以改变的。 元组 – Tuple 元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号里，元素之间用逗号隔开。 元组中的元素类型也可以不相同： 123&gt;&gt;&gt; tu = (2020,2030,'python')&gt;&gt;&gt; print(tu,type(tu),len(tu))(2020, 2030, 'python') &lt;class 'tuple'&gt; 3 元组与字符串类似，可以被索引且下标索引从0开始，也可以进行截取/切片。 12345&gt;&gt;&gt; tu = (2020,2030,'python')&gt;&gt;&gt; tu[2]'python'&gt;&gt;&gt; tu[0:2](2020, 2030) 其实，可以把字符串看作一种特殊的元组。 1234567&gt;&gt;&gt; tup = (1, 2, 3, 4, 5, 6)&gt;&gt;&gt; print(tup[0], tup[1:5])1 (2, 3, 4, 5)&gt;&gt;&gt; tup[0] = 11 # 修改元组元素的操作是非法的Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment 虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。 构造包含0个或1个元素的tuple是个特殊的问题，所以有一些额外的语法规则： 123456&gt;&gt;&gt; tu_null = () # 空元组&gt;&gt;&gt; print(tu_null)()&gt;&gt;&gt; tu_one = (20,) # 一个元素，需要在元素后添加逗号&gt;&gt;&gt; tu_one(20,) 另外，元组也支持用+操作符： 123&gt;&gt;&gt; tup1, tup2 = (1, 2, 3), (4, 5, 6)&gt;&gt;&gt; print(tup1+tup2)(1, 2, 3, 4, 5, 6) string、list和tuple都属于sequence（序列）。 注意： 1、与字符串一样，元组的元素不能修改。 2、元组也可以被索引和切片，方法一样。 3、注意构造包含0或1个元素的元组的特殊语法规则。 4、元组也可以使用+操作符进行拼接。 集合 – Sets 集合（set）是一个无序不重复元素的集。 基本功能是进行成员关系测试和消除重复元素。 可以使用大括号 或者 set()函数创建set集合，注意： 创建一个空集合必须用 set() 而不是 { }，因为{ }是用来创建一个空字典。 123456789101112131415161718192021&gt;&gt;&gt; student = &#123;'Tom', 'Jim', 'Mary', 'Tom', 'Jack', 'Rose'&#125;&gt;&gt;&gt; print(student) # 重复的元素被自动去掉&#123;'Mary', 'Rose', 'Jim', 'Tom', 'Jack'&#125;&gt;&gt;&gt; 'Rose' in student # membership testing（成员测试）True&gt;&gt;&gt; # set可以进行集合运算...&gt;&gt;&gt; a = set('abracadabra')&gt;&gt;&gt; a&#123;'r', 'a', 'c', 'd', 'b'&#125;&gt;&gt;&gt; b = set('alacazam')&gt;&gt;&gt; b&#123;'a', 'l', 'm', 'c', 'z'&#125;&gt;&gt;&gt; a - b # a和b的差集&#123;'d', 'r', 'b'&#125;&gt;&gt;&gt; a | b # a和b的并集&#123;'r', 'a', 'l', 'm', 'c', 'd', 'b', 'z'&#125;&gt;&gt;&gt; a &amp; b # a和b的交集&#123;'c', 'a'&#125;&gt;&gt;&gt; a ^ b # a和b的补集-- a和b中不同时存在的元素&#123;'d', 'r', 'b', 'z', 'l', 'm'&#125; 字典 --Dictionary 字典（dictionary）是Python中另一个非常有用的内置数据类型。 字典是一种映射类型（mapping type），它是一个无序的键 : 值对集合。 关键字必须使用不可变类型，也就是说list和包含可变类型的tuple不能做关键字。 在同一个字典中，关键字还必须互不相同 – ** 不重复**。 123456789101112131415161718&gt;&gt;&gt; dic = &#123;&#125; # 创建空字典&gt;&gt;&gt; tel = &#123;'Jack':1557, 'Tom':1320, 'Rose':1886&#125;&gt;&gt;&gt; tel&#123;'Tom': 1320, 'Jack': 1557, 'Rose': 1886&#125;&gt;&gt;&gt; tel['Jack'] # 主要的操作：通过key查询1557&gt;&gt;&gt; del tel['Rose'] # 删除一个键值对&gt;&gt;&gt; tel['Mary'] = 4127 # 添加一个键值对&gt;&gt;&gt; tel&#123;'Tom': 1320, 'Jack': 1557, 'Mary': 4127&#125;&gt;&gt;&gt; list(tel.keys()) # 返回所有key组成的list['Tom', 'Jack', 'Mary']&gt;&gt;&gt; sorted(tel.keys()) # 按key排序['Jack', 'Mary', 'Tom']&gt;&gt;&gt; 'Tom' in tel # 成员测试True&gt;&gt;&gt; 'Mary' not in tel # 成员测试False 构造函数 dict() 直接从键值对sequence中构建字典，当然也可以进行推导，如下： 12345678&gt;&gt;&gt; dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])&#123;'jack': 4098, 'sape': 4139, 'guido': 4127&#125;&gt;&gt;&gt; &#123;x: x**2 for x in (2, 4, 6)&#125;&#123;2: 4, 4: 16, 6: 36&#125;&gt;&gt;&gt; dict(sape=4139, guido=4127, jack=4098)&#123;'jack': 4098, 'sape': 4139, 'guido': 4127&#125; 另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。 注意： 1、字典是一种映射类型，它的元素是键值对。 2、字典的关键字必须为不可变类型，且不能重复。 3、创建空字典使用{ }。","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}]},{"title":"Python3 基础语法","slug":"Python3 基础语法","date":"2020-05-01T07:57:38.464Z","updated":"2020-05-01T08:40:49.412Z","comments":true,"path":"2020/05/01/Python3 基础语法/","link":"","permalink":"http://yoursite.com/2020/05/01/Python3%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Python3 基础语法 Python3 基础语法 编码 默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串但是 nuicode 字符串。 你也可以为源码文件指定不同的编码： 1# -*- coding: cp-1252 -*- 标识符 标识符由字母、数字、下划线 ’_‘ 组成； 不能以数字开头，第一个字符必须是字母或者下划线 ‘_’； 标识符区分大小写。 在Python3中，非-ASCII （* [^\\x00-\\x7f] *）标识符也是允许的。 Python 可以同一行显示多条语句，方法是用分号* ;* 分开，如： 123&gt;&gt;&gt; print ('hello');print ('runoob');hellorunoob Python保留字 保留字即关键字，不能用于标识符名称。 Python 的标止库提供了一个 keyword module，可以输出当前版本所有的关键字。 123&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 注释 单行注释： 12#单行注释print(\"hello world\") 多行注释-三个单引号（’’’）： 123456'''多行注释多行注释多行注释'''print(\"hello world\") 多行注释-三个双引号（”“”）： 123456\"\"\"多行注释多行注释多行注释\"\"\"print(\"hello world\") 行与缩进 python最具特色的就是使用缩进来表示代码块。缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。 实例: 1234if True: print (\"True\")else: print (\"False\")","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}]},{"title":"Python安装","slug":"Python3 安装","date":"2020-05-01T06:59:32.256Z","updated":"2020-05-01T08:40:49.419Z","comments":true,"path":"2020/05/01/Python3 安装/","link":"","permalink":"http://yoursite.com/2020/05/01/Python3%20%E5%AE%89%E8%A3%85/","excerpt":"","text":"Python安装 Python下载 Python最新源码，二进制文档，新闻资讯等可以在Python的官网查看到： Python官网：https://www.python.org/ 你可以在以下链接中下载 Python 的文档，你可以下载 HTML、PDF 和 PostScript 等格式的文档。 Python文档下载地址：https://www.python.org/doc/ Python安装 ython已经被移植在许多平台上（经过改动使它能够工作在不同平台上）。 您需要下载适用于您使用平台的二进制代码，然后安装Python。 如果您平台的二进制代码是不可用的，你需要使用C编译器手动编译源代码。 编译的源代码，功能上有更多的选择性， 为python安装提供了更多的灵活性。 以下是使用Window访问官网的下载地址：https://www.python.org/downloads/ 以下为不同平台上安装 Python 的方法： Unix &amp; Linux 平台安装 Python: 以下为在 Unix &amp; Linux 平台上安装 Python 的简单步骤： 打开 WEB 浏览器访问https://www.python.org/downloads/source/ 选择适用 于Unix/Linux 的源码压缩包。(例如: 下载 Python 3.7.7版源码包) Python-3.7.7.tgz 下载及解压压缩包。(tar -xzvf 包名 解压地址) 如果你需要自定义一些选项修改Modules/Setup 执行 ./configure 脚本 make make install 执行以上操作后，Python 会安装在 /usr/local/bin 目录中，Python 库安装在 /usr/local/lib/pythonXX，XX 为你使用的 Python 的版本号。 Window 平台安装 Python: 以下为在 Window 平台上安装 Python 的简单步骤： 打开 WEB 浏览器访问https://www.python.org/downloads/windows/ 在下载列表中选择Window平台安装包，包格式为：python-XYZ.exe 文件 ， XYZ 为你要安装的版本号。 下载后，双击下载包，进入 Python 安装向导，安装非常简单，你只需要使用默认的设置一直点击&quot;下一步&quot;直到安装完成即可。 MAC 平台安装 Python: MAC 系统一般都自带有 Python2.x版本 的环境，你也可以在链接 https://www.python.org/downloads/mac-osx/ 上下载最新版安装。","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}]},{"title":"python3教程","slug":"Python3 教程","date":"2020-05-01T03:16:02.765Z","updated":"2020-05-01T08:40:49.415Z","comments":true,"path":"2020/05/01/Python3 教程/","link":"","permalink":"http://yoursite.com/2020/05/01/Python3%20%E6%95%99%E7%A8%8B/","excerpt":"","text":"python3教程 Python的3.0版本，常被称为Python 3000，或简称Py3k。相对于Python的早期版本，这是一个较大的升级。为了不带入过多的累赘，Python 3.0在设计的时候没有考虑向下兼容。 查看python3版本 1python --version 显示版本： 1Python 3.7.5 第一个python程序 1print(\"Hlello,World!\") 输出： 1Hlello,World! 脚本式编程 通过脚本参数调用解释器开始执行脚本，直到脚本执行完毕。当脚本执行完成后，解释器不再有效。 让我们写一个简单的 Python 脚本程序。所有 Python 文件将以 .py 为扩展名。将以下的源代码拷贝至 test.py 文件中。 1print(\"Hlello,World!\") 这里，假设你已经设置了 Python 解释器 PATH 变量。使用以下命令运行程序： 1$ python test.py 输出结果： 1Hlello,World! Linux系统下 让我们尝试另一种方式来执行 Python 脚本。修改 test.py 文件，如下所示： 123#!/usr/bin/pythonprint (\"Hlello,World!\") 这里，假定您的Python解释器在/usr/bin目录中，使用以下命令执行脚本： 12chmod +x test.py # 脚本文件添加可执行权限./test.py #运行脚本 输出结果： 1Hello,World!","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}],"keywords":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}]}]}